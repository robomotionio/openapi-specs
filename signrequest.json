{
  "openapi": "3.0.0",
  "info": {
    "title": "SignRequest API",
    "description": "API for SignRequest.com\n\n# Getting Started\n\nThe SignRequest REST API enables you to send out signature requests. Using the API you will always have all the functionality as when using our User Interface, plus more.\n\nWhen you're logged in and you have a Team enabled, you can also use the endpoints in your browser by visiting them. For example:\n\n`https://<your_subdomain>.signrequest.com/api/v1/`\n\nIt is also possible to receive events from SignRequest when, for example, a document has been signed. This way you can keep your application in sync with SignRequest without polling document endpoints. For this a callback url needs to be provided in the [team API settings page](/#/teams).\n\n## Sandbox Team\n\nThe easiest way to get started is by creating a free [Sandbox Team](/#teams?sandbox=true). Sandbox teams allow you to test out the entire SignRequest product without incurring charges. Everything works the same as a paid plan, except that all documents will be watermarked.\n\n## API Token\n\nIn order to use the API you first need to obtain an API token. You can create an API token in the [team API settings page](/#/teams). \n\nUse tokens with a `Authorization: Token YOUR_TOKEN_HERE` header in your requests when making requests to the SignRequest API.\n\ncURL example:\n\n```bash\ncurl -H 'Authorization: Token YOUR_TOKEN_HERE' -H 'Content-Type: application/json'\n```\n\n## Creating a Document\n\nIn order to send out a SignRequest, we first need to create a document. There are three ways to create a document using the [documents endpoint](#operation/documents_create).\n\n1) Sending a POST request that includes a `template` uuid, created via our User Interface. For example: \n\n`https://<your_subdomain>.signrequest.com/api/v1/templates/uuid/`\n\n2) By sending a `file_from_url`, which is a file publicly available in the cloud. This way, SignRequest will download the document from that location; therefore, make sure it is not a private link.\n\n3) By providing a base64 encoded document, located in your local environment, using the parameter `file_from_content`. Together with the file name for this content, using the parameter `file_from_content_name`, for example: \n\n```\nfile_from_content: pdf_encoded_base64,\nfile_from_content_name: 'demo_document.pdf',\nname: 'demo_document.pdf',\n```\n\nThis can be useful if you need to send more than one file (nested, when using [signrequest-quick-create endpoint](#operation/signrequest-quick-create_create)) configuration data. Please be sure to add the correct extension to the filename (e.g. my_pdf_file.pdf) in order for SignRequest to be able to determine the content type of the content.\n\nAs mentioned above, when using `file_from_url`, this url needs to be publicly available for SignRequest to download. The download location may also be a Google Drive shareable link for documents (`application/vnd.google-apps.document`) and files (`application/vnd.google-apps.file`). If the download location returns a content type of `text/plain` or `text/html`, SignRequest will do its best to make a PDF out of it. This can be used if you want to dynamically create PDF documents from web pages without making a PDF yourself. An `external_id` is optional and can be used in order to have a reference to the document in your systems. The `name` field is also optional and can be customized, defaults to the filename (including extension).\n\n\n## Sending a SignRequest\n\nOnce you have successfully created a document, you can use the [signrequests endpoint](#operation/signrequests_create) to send a SignRequest using the `url` returned from the [documents endpoint](#operation/documents_create). For example:\n\n`document: https://<your_subdomain>.signrequest.com/api/v1/documents/uuid/`\n\nThe minimal data needed to send out a SignRequest is the following:\n\n```json\n{\n    \"document\": \"https://signrequest.com/api/v1/documents/f2bac751-4fa1-43f1-91de-a1b8905c239a/\", \n    \"from_email\": \"you@yourcompany.com\", \n    \"message\": \"Please sign this document.\\n\\nThanks!\", \n    \"signers\": [\n        {\n            \"email\": \"tech-support@signrequest.com\"\n        }\n    ]\n}\n```\n\nNote that we always also create a signer for the `from_email` sending the SignRequest, however for this signer the `needs_to_sign` flag is set to `false` meaning that this signer will **not** get a SignRequest.\n\n## Quick Create a SignRequest\n\nIn some cases it might be desirable to create a document and send the SignRequest in one API call. This can be done using the [signrequest-quick-create endpoint](#tag/signrequest-quick-create). This endpoint takes all of the fields of the [documents](#operation/documents_create) and [signrequests](#operation/signrequests_create) endpoints together, creates the document, and sends the SignRequest.\n\n## Browsable API\n\nIn addition to our API docs, you can also explore our API endpoints using our [browsable API](/api/v1/). There you'll be able to browse our various endpoints and even perform requests against our live API.\n\n# Working with a SignRequest\n\n## Add attachments to a SignRequest\n\nAttachments can be added to a SignRequest using the [document-attachments endpoint](#operation/document-attachments_create). Signers will be able to download and read them before signing, but these will not be signed themselves. Document attachments can only be added when the SignRequest is not created yet.\n\nNotice: This only works for documents created using the `file_from_url` and `file_from_content` methods. For documents created using a `template`, attachments should be added via our User Interface.  \n\n## Customizing the SignRequest email\n\nIf the Team has a custom color and logo these will be used in the SignRequest email. The `subject` and `message` fields can also be used to customize the email even further. The `message` may contain the following html tags: `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`. Be aware that when the text to html ratio is too high, the email may end up in spam filters. Custom styles on these tags are not allowed.\n\nWhen the `from_email_name` field is provided, this name will be used in the `From` email header as such `{from_email_name} <no-reply@signrequest.com>`. By default `Sender Name (sender@email.com) | SignRequest` is used as the `from_email_name`. Note that it's currently not possible to change the email address used to send a SignRequest.\n\n## Resend the SignRequest email(s)\n\nThe [resend_signrequest_email](#operation/signrequests_resend_signrequest_email) endpoint can be used to resend the SignRequest email as a reminder to all signers who didn't sign yet but did receive the email before.\n\n## Cancel a SignRequest\n\nA SignRequest that has not been fully signed or declined yet can be cancelled using the [cancel_signrequest endpoint](#operation/signrequests_cancel_signrequest). By doing so all signers that have not signed yet will not be able to open and sign the document anymore.\n\n\n## Download a signed document\n\nWhen a SignRequest has been signed the `pdf` field on the document resource will be filled with a link to download the signed PDF. The signing log PDF can be downloaded from the `pdf` field contained within the `signing_log` object field on the document resource.\n\nThe recommended way to download the files and store them in your own systems is to setup the [Events callback](#section/Events/Events-callback) functionality and have your application download the files on the `signed` (Document signed) event. Please note that the download links expire and are regenerated on every API call / events callback so download the files right away when needed.\n\n## Deleting documents\n\nTo delete a document for the owner of the document, send a DELETE request to the [document resource url](#operation/documents_delete). Note that at this point this only makes the document unavailable for the sender. For all signers that do not have a registered SignRequest account, a grace period is started to give them a chance to download the signed document. After this grace period the document will be deleted for these signers automatically. When all signers have requested a delete (manually, automatically, or via the API) or do not have a registered SignRequest account and the grace period has lapsed, the document will be fully deleted.\n\n### Automatic document deletion\n\nTo automatically delete a document the `auto_delete_days` field on a document can be set to a number of days after which a finished document (signed/cancelled/declined) will be automatically deleted. The behavior is the same as doing a DELETE on the document resource url X number of days after the document is finished. When the document is scheduled to be deleted the `auto_delete_after` will hold the date after which it will be deleted.\n\nNote that we can make exceptions (to delete documents right away and entirely) for integration partners when they make the document available in other systems and users do not use SignRequest directly. Please [contact us](https://signrequest.com/en/contact/) to request an app screening if this functionality is required.\n\n## Chaining multiple documents\n\nWhen sending a SignRequest, it's possible to reference a document uuid (the same uuid used for the 'document' parameter sent to /signrequests/) in the `after_document` field in the `signers'` array. This should reference a document that the signer should be redirected to after signing. Since the signer is redirected to this document immediately after signing the other document, they do NOT get a SignRequest email. Note that resending the SignRequest email will trigger the SignRequest email even though they didn't receive one before.\n\nWhen `after_document` references a document where the signer in question already has signed or declined they will still receive a SignRequest email as we cannot redirect them anymore. It's only possible to reference documents that are not fully signed (or declined) yet.\n\nA `redirect_url` field is also available on a `signer` and on the `signrequest` (the default when not specified on the individual signers explicitly). When specified SignRequest will redirect to this url when a document is signed. Note that this only works when there are no chained documents for this signer anymore.\n\nThe `redirect_url_declined` field is available on `signer` and on `signrequest` for the case that a user declines the document\n\nDespite the limitations, chaining also works on the [signrequest-quick-create endpoint](#operation/signrequest-quick-create_create). When creating a SignRequest on that endpoint, you get a reference to the created document in the `document` field back which can be used in the next call to `signrequest-quick-create` when creating a chain with `after_document`.\n\nIn general, to generate multi-docs via API, the best practice is to create documents and SignRequests separately. For example, to create a multi-doc containing three chained documents, it will be necessary to create three documents first (via POST /documents/) and then three SignRequests (via POST /signrequests/) for each one of those documents. Hence, a multi-doc SignRequest should be generated in reverse, from the last to the first document. With the last SignRequest containing only the first document's uuid and no `after_documents` included.\n\n**Example flow - SignRequest containing 3 documents**\n\n**SignRequest 3:** contains document 3 in `document` and document 2 in `after_document`.\n**SignRequest 2:** contains document 2 in `document` and document 1 in `after_document`.\n**SignRequest 1:** contains document 1 in `document`.\n\nThus, if a multi-doc contains a X number of documents, it will be necessary to create a X number of document uuids and the same X number of SignRequests.\n\n`X Document uuids = X SignRequests`\n\n## Signer language\n\nIf known the language of the signer can be set in the `language` field. This will determine the language of the SignRequest email. The SignRequest browser interface language is by default set to the location, browser, or user account settings when available.\n\nTo force the language of the interface when a signer lands on the signing page the field `force_language` on the signer can be set to `true`. Note that if the language of the signer is not known it's best to not force the language.\n\nAvailable languages:\n\n`en` English  \n`en-gb` English (GB)  \n`nl` Dutch  \n`fr` French  \n`de` German  \n`he` Hebrew  \n`da` Danish  \n`fi` Finnish  \n`hu` Hungarian  \n`it` Italian  \n`no` Norwegian  \n`pl` Polish  \n`pt` Portuguese  \n`es` Spanish  \n`sv` Swedish  \n`ru` Russian\n\n\n## Text message and bank account verification\n\nFor a higher degree of authentication of your signers it is possible to enable text message phone number verification and bank account verification. These verifications can be enabled by providing the phone number to `verify_phone_number` (international format including the plus-sign) and/or the bank account to `verify_bank_account` on a signer. Currently it is only possible to verify bank accounts using [iDEAL](https://www.ideal.nl/en/).\n\nWhen enabled, signers can only sign (finalize) a document when they have verified their phone number by a code supplied to them by a text message and/or make a payment of 1 cent. The verifications are logged and visible in the SignRequest signing log after completion.\n\nPlease note that we cannot force signers to make a payment using a specific bank account. Therefore the content of the field may also specify what type of account to use instead of a specific bank account number, e.g.: \"the bank account you want to use for paying the rent.\"\n\nFor this service additional fees apply. Please [contact us](https://signrequest.com/en/contact/) for a quote.\n\n## Disable signing tools/features\n\nIt is possible to disable certain tools/features signers have when signing a document. The following flags can be set to `true` on the signrequest model to disable these features.\n\n- `disable_text`: disable adding of text\n- `disable_date`: disable adding of dates\n- `disable_attachments`: disable uploading/adding of attachments\n- `disable_text_signatures`: disable usage of signatures generated by typing (text)\n- `disable_upload_signatures`: disable usage of uploaded signatures (images)\n\nPlease note that we strongly **discourage you to disable features** as these are carefully chosen for optimal usability of the SignRequest product.\n\n## Required attachments\n\nTo require signers to upload attachments (like a passport for example) the `required_attachments` field can be used. The field takes an array of objects with one parameter `name`, for example: `required_attachments: [{\"name\": \"Passport\"}]`\n\n\n## Templates\n\nIn the frontend application it is possible to create templates. These templates, for Teams and Personal accounts, can be found in the [templates resource](#tag/templates). In order to send a SignRequest using a template, reference the resource url of the template in the `template` field. This works in both the [documents](#tag/documents) and the [signrequest-quick-create](#tag/signrequest-quick-create) resources.\n\n## Automatic reminders\nTo enable automatic reminders set the `send_reminders` boolean to `true` on the [SignRequest resource](#tag/signrequests). When enabled SignRequest will automatically remind signers to sign a document on day 3, 8, 13 and 18 (or less if the document has been digitally signed already).\n\n# Preparing a document\n\nUsing the SignRequest frontend web application you have the option to \"prepare\" a document. This helps the receiver as they can only sign the document at the designated place.\n\nUsing the API you can also **prepare a document by using tags** to specify where a signer needs to add a date, text, checkbox, and/or a signature.\n\nTags need to start with `[[` and end with `]]`. The tag data is separated by a pipe `|`. The first letter of the tag represents the tag type and must be one of the following:\n\n- `t` for text\n- `d` for date\n- `s` for signature\n- `c` for checkbox\n\nThe second piece of data is an integer representing the index of the signer for which this placeholder is intended. The numbers in the tags are used to make distinctions between the signers and group multiple tags (input fields) to one specific signer.\n\nThe template tags are assigned to the order at which the email addresses are added to the contact field and are not the same as the order of signing. This means that for example `s|1` can be the first or last signer depending on what you specified in the order of signing (if used of course).\n\nAs the sender is always the first email address added, this means the sender is always `s|0`. If the sender does not need to add a signature or other data input, then `s|0` will be assigned to the next in line.\n\nMismatches in the amount of declared placeholders and available signers will be silently ignored. The extra placeholders will not show up if more than the amount of signers **OR** signers just get an unprepared document to sign when there were no placeholders declared for them.\n\nExamples:\n\n```\n[[s|0                 ]]  // A signature for the first signer OR the owner/sender when they need to sign.\n[[c|0                 ]]  // A checkbox placeholder for the first signer\n[[d|1                 ]]  // A date input placeholder for the second signer\n[[t|2                 ]]  // A text input placeholder for the third signer\n```\n\nThe height / width (font size) and the position of the tag in your document matters. Also as you do not want the **placeholder tag to show up in the document** to avoid this you need to make the font color match the background. Sign this demo document for an example (the color is left gray to see the tags):\n\n```html\nhttps://signrequest.com/#/?api=v1&who=m&from_email=you@yourcompany.com&doc_url=https%3A%2F%2Fsignrequest.com%2Fstatic%2Fdemo%2FSignRequestTagsExample.pdf\n```\n\nNote that the font chosen can make a difference in the bounding box margins and position. For most fonts the top margin will be bigger as desired. For this reason make sure to **leave enough space or double the line height** in order for the placeholder to not overlap the line above.\n\n## Tag modifiers\nThere are multiple tag modifiers available to further customize the tags. The following key / value pairs can be used after the signer index.\n\n- `r` to make a placeholder required to be filled: `1` / `true` for required `0` / `false` for not required\n- `m` to make a text placeholder multiline: `1` / `true` for multiline `0` / `false` for single line (default)\n- `n` to set a label/name on a text placeholder: 'a string'\n- `p` to prefill text/dates on a text/date placeholder: 'a string', for a date placeholder this can also be set to `0` / `false` to not prefill the current date.\n- `id` to assign an `external_id` to the placeholder: \"your_id\" (also see [Retrieving signer input](#section/Preparing-a-document/Retrieving-signer-input) and [Prefill tags](#section/Preparing-a-document/Prefill-tags-templates))\n\nExamples:\n\n```\n[[c|0|r:1                                ]]  // A checkbox that cannot be skipped (needs to be checked or not)\n[[c|0|r:0                                ]]  // A checkbox that can be skipped\n[[c|0|p:1                                ]]  // A checkbox that is by default checked (can be changed)\n[[d|0|n:Birth date|p:0                   ]]  // A date that is not prefilled with the date of signing and has the label 'Birth date'\n[[t|0|n:City|p:New York|id:customer_city ]]  // A text input placeholder with the label 'City', prefilled with the text 'New York' and an external_id of 'customer_city' that will be available later in the 'inputs' field (see: 'Retrieving signer input') and can be used to prefill the tag using prefill_tags on the document resource (see: 'Prefill tags').\n```\n\nNote that placeholder names / prefilled data can get quite long. If this impacts the placeholder width/height you can choose to make the font between the opening `[[` and closing `]]` tags (really) small. The tag configuration does not need to be human readable as the text is extracted from the PDF format directly.\n\n## Prefill tags / templates\n\nInstead of generating a new document and use the `p` tag modifier to prefill signer input data it is also possible to use `prefill_tags`. For this to work all tags need to have an `id` as this is needed to reference the tag.\n\nExample:\n\n```\n[[c|0|id:checkbox_1                      ]]  // Should be checked\n[[c|0|id:checkbox_2                      ]]  // Should not be checked\n[[d|0|n:Birth date|id:birth_date         ]]  // Should be prefilled with the birth date of the signer\n[[t|0|n:City|id:customer_city            ]]  // Should be prefilled with 'New York'\n```\n\nNow when a document contains the tags above you can prefill them using the `prefill_tags` field on document by referencing the 'id'. Note that tags are only prefilled, and thus visible, when the signer belonging to the prefilled tag opens the document. Only after a signer, with prefilled tags, has signed, those tags will also be visible to other signers opening the document. So for example, when the sender signer (index 0) has tags assigned (and prefilled using the api) and there is no particular order in which the signers sign (all at the same time), and the second signer opens the document the tags will not be visible. However, when the sender signer signs before the second signer opens the document the tags will be visible while signing.\n\n```json\n\"prefill_tags\": [\n    {\"external_id\":\"checkbox_1\", \"checkbox_value\":\"true\"},\n    {\"external_id\":\"checkbox_2\", \"checkbox_value\":\"false\"},\n    {\"external_id\":\"birth_date\", \"date_value\":\"1984-12-31\"},  // must be in ISO format ([YYYY]-[MM]-[DD])\n    {\"external_id\":\"customer_city\", \"text\":\"New York\"}\n]\n```\n\nIf you are using templates created from within the SignRequest app you can also set the `external_id` of a template tag in the advanced section when editing a tag.\n\nNote that it's also possible to add these tags when using the <a href=\"#section/Frontend-API/SignRequest-js-client-(beta)\">SignRequest-js client</a> and the [Frontend API](#section/Frontend-API).\n\n## Prepare using the web interface\n\nIt is also possible to have the sender of a SignRequest prepare the document before sending the request out. To use this functionality, set the `is_being_prepared` flag on the SignRequest resource to `true`. When doing so the SignRequest will not be sent out to the recipient(s) and the `prepare_url` field will be set to a url where your application can redirect the sender to. Please note that if the sender does not have a SignRequest account they will be asked to verify their email after preparing the document. If you're an integration partner please [contact us](https://signrequest.com/en/contact/) for more possibilities when integrating this functionality.\n\nExample:\n\n```json\n{\n    \"file_from_url\": \"https://signrequest.com/static/demo/SignRequestDemoDocument.pdf\",\n    \"from_email\": \"you@yourcompany.com\",\n    \"who\": \"mo\",\n    \"is_being_prepared\": \"true\",\n    \"signers\": [{\"email\": \"you@yourcompany.com\"}, {\"email\": \"tech-support@signrequest.com\"}]\n}\n```\n\nNote that it's perfectly fine to also include tags in the document. The sender will be able to change / remove them.\n\n## Retrieving signer input\n\nAll text, date, and boolean inputs of signers after a signer signs are available in the `inputs` field of a signer as text. This can be helpful if you need to update your systems based on data signers add to a document.\n\n```json\n\"inputs\": [\n    {\n        \"type\": \"d\",  // 's' (signature input), 't' (text input), 'd' (date input) or 'c' (checkbox input)\n        \"page_index\": 0,  // index of the page this input resides on\n        \"text\": \"09-25-18\",  // text as seen on the document (only for date and text inputs)\n        \"checkbox_value\": null,  // true or false (only for checkbox inputs)\n        \"date_value\": \"2018-09-25\",  // the date in ISO format ([YYYY]-[MM]-[DD])\n        \"external_id\": null  // optionally the external id assigned to a tag (helpful if you need to identify a specific input, also see 'Tag modifiers')\n    }\n]\n```\n\n## Tags Example\n\nSigner 0: this is the first person that needs to sign (including you).\n\n![Signer 0](https://signrequest.com/assets/images/blogs/template-tags-electronic-signature-0.bf35c985.png)\n\nSigner 1: this is the second person that needs to sign (including you).\n\n![Signer 1](https://signrequest.com/assets/images/blogs/template-tags-electronic-signature-1.335ad0c8.png)\n\nThe result in SignRequest:\n\n![Result in SignRequest](https://signrequest.com/assets/images/blogs/tags-example.2bb33d7f.png)\n\n## Example Documents\n\nYou can quickly test this feature with our example documents:\n\n1. [Basic example document](https://docs.google.com/document/d/1oI2R1SxfMNZXiz3jCQvorpoklF9xq_dCJnOpkI-zo80/edit?usp=sharing)\n2. [Advanced example document](https://docs.google.com/document/d/1-gzqym9clQ1a193JGocXUeIX92cqPINBHOBeGxbDASw/edit)\n\nThese are shared Google Docs documents with example tags. If you have our Google Docs Add-on you can directly send a SignRequest!\n\nIf you don't have our Google Docs Add-on for electronic signatures, go to \"Add-ons\" in the Google Docs menu bar and install the Add-on for free. Then, go back to \"Add-ons\" and click \"SignRequest\".\n\n## Walkthrough Video\n\nWe also have a walkthrough video on YouTube about using templates with tags in a base document:\n\n[![Templates with tags in a base document](https://img.youtube.com/vi/y5U5WqTqZBQ/0.jpg)](https://www.youtube.com/watch?v=y5U5WqTqZBQ)\n\n# Events\n\n## Events callback\n\nIn order to receive the `events` as a callback to your application a **callback url** needs to be set in the [team API settings](/#/teams) page. When set, SignRequest will POST events as `application/json` to this endpoint. Your endpoint should return a 200 OK response. SignRequest will retry delivering events in the case of a timeout or a 500 response from your server. It first waits one minute and then increases on every subsequent attempt according to a Fibonacci sequence for a maximum of ten attempts (1, 1, 2, 3, 5, etc).\n\nIt is also possible to change the **callback url on a per document basis**. To use this functionality you can set the callback url using the `events_callback_url` field when [creating a document](#operation/documents_create) or when using the [signrequest-quick-create endpoint](#tag/signrequest-quick-create).\n\nPlease be aware that we might add more event types in the future so code defensively for that.\n\nFor an example of how an event receiver can be written checkout this [repository](https://github.com/SignRequest/signrequest-event-receiver).\n\nThe following event types are available:\n\n- `convert_error`: Document convert error  \n- `converted`: Document converted  \n- `sending_error`: Document sending error  \n- `sent`: Document sent  \n- `declined`: Document declined  \n- `cancelled`: Document cancelled  \n- `expired`: Document expired  \n- `signed`: Document signed  \n- `signer_signed`: Signer signed  \n- `signer_email_bounced`: Signer email bounced  \n- `signer_viewed_email`: Signer viewed email  \n- `signer_viewed`: Signer viewed document  \n- `signer_forwarded`: Signer forwarded document  \n- `signer_downloaded`: Signer downloaded  \n- `signrequest_received`: SignRequest received  \n\nStatus codes:\n\n- `ok`: ok\n- `error`: error\n\nThe event status will be `error` for the following events: `convert_error`, `sending_error`, and `signer_email_bounced`.\n\nThe document status field can have the following codes:\n\n- `co`: converting\n- `ne`: new\n- `se`: sent\n- `vi`: viewed\n- `si`: signed\n- `do`: downloaded\n- `sd`: signed and downloaded\n- `ca`: cancelled\n- `xp`: expired\n- `de`: declined\n- `ec`: error converting\n- `es`: error sending\n\nExample callback request:\n\n```json\n{\n    \"document\": {\n        \"api_used\": true, \n        \"attachments\": [], \n        \"external_id\": \"your_id_of_this_document\", \n        \"file\": \"signrequest download url of the uploaded file\", \n        \"file_from_url\": \"url where signrequest downloaded the document, if this functionality was used\", \n        \"name\": \"document.pdf\", \n        \"pdf\": null, \n        \"prefill_tags\": [], \n        \"security_hash\": null, \n        \"signing_log\": null, \n        \"signrequest\": null, \n        \"status\": \"co\", \n        \"team\": {\n            \"name\": \"the_name_of_your_team\", \n            \"subdomain\": \"the_subdomain_of_your_team\"\n        }, \n        \"template\": null, \n        \"url\": \"https://signrequest.com/api/v1/documents/f2bac751-4fa1-43f1-91de-a1b8905c239a/\", \n        \"user\": null, \n        \"uuid\": \"f2bac751-4fa1-43f1-91de-a1b8905c239a\"\n    }, \n    \"event_hash\": \"89365cda10349ced9c3fd9c457372b37ad2e723c5b9f11a4d0b2c16724d8a2e7\", \n    \"event_time\": \"1537889008\", \n    \"event_type\": \"converted\", \n    \"signer\": null, \n    \"status\": \"ok\", \n    \"team\": {\n        \"name\": \"the_name_of_your_team\", \n        \"subdomain\": \"the_subdomain_of_your_team\"\n    }, \n    \"timestamp\": \"2018-09-25T15:23:28.836457Z\", \n    \"token_name\": \"Token\", \n    \"uuid\": \"ffffd4dd-89c7-4133-ba2d-960f65c8d395\"\n}\n```\n\nIf the event is **signer related** the `signer` field will contain all the signer data.\n\nAll event data can also be fetched using the REST API [Events resource](#tag/events). Be sure to check that out if you're developing your endpoint and see how the data looks.\n\nYou can check the authenticity (that the event really came from SignRequest) by generating and comparing the `event_hash` that comes with the event. The `event_hash` is generated with the HMAC algorithm using your API Token as a key in SHA256 digest mode.\n\nOpenSSL shell example:\n\n```bash\necho -n \"${event_time}${event_type}\" | openssl dgst -sha256 -hmac \"YOUR_TOKEN_HERE\"\n```\n\nwhich expands to:\n\n```bash\necho -n \"1537889008converted\" | openssl dgst -sha256 -hmac \"YOUR_TOKEN_HERE\"\n675ceef2ce146de8ba8d24ac878cdd1a0f5868b37dfe9e30699387eb18e17977\n```\n\nIf you have multiple API tokens created you can identify the used token by the `token_name` (if you provided one).\n\nAlways use **SSL enabled endpoints**!\n\nDeveloping your callback endpoint locally? Checkout [UltraHook](http://www.ultrahook.com/) to receive webhooks on localhost, nifty!\n\nFor an example of an Events Receiver using Node.js, check the following repository (using Ngrok: https://ngrok.com/docs): https://github.com/SignRequest/SignRequest-events-receiver-Nodejs\n\n## Event webhooks\n\nTo receive only specific event callbacks, webhook subscriptions can be created for Teams and for Personal accounts. The resource takes an `event_type`, `callback_url` and optionally a `name` to easily identify what webhook is used for. The `integration` field can also be set when this hook is specific to one of the SignRequest supported integrations. Check out the [webhooks resource](#tag/webhooks) for all possible event types to subscribe to. When the webhooks are used on personal accounts these webhooks also receive the `signrequest_received` event which can be used to notify users that they have received a new SignRequest. However, creating webhook subscriptions for personal accounts requires a SignRequest session (logged in user) or Basic auth using a username and password.\n\n## Disable all SignRequest email events\n\nIt is possible to disable all SignRequest status emails as well as the email that contains the signed documents. When using this functionality the following events will not generate a SignRequest email:\n\n- `sent`: Document sent\n- `signer_email_bounced`: Signer email bounced\n- `signer_viewed_email`: Signer viewed email\n- `signer_viewed`: Signer viewed document\n- `signer_signed`: Signer signed\n- `signed`: Document signed\n- `declined`: Document declined\n- `cancelled`: Document cancelled\n\nTo enable this feature set the `disable_emails` flag on the [SignRequest resource](#tag/signrequests) to true. \n\nNote that the event emails will only be disabled if there is `callback_url` available for the document as your application is expected to notify users instead of SignRequest. The initial SignRequest email (that contains the link to sign) can only be disabled by using the [Embed url](#section/Additional-signing-methods/Embed-url) functionality.\n\n# Frontend API\n\nAnother option to help your users sending SignRequests is using the \"frontend\" api. This involves no token and is merely used to \"prefill\" the SignRequest box found at the homepage for your users. The only requirement is that the document to send out is publicly available in order for SignRequest to download the file. Shareable links of Google Drive documents are also supported here.\n\nGET params for prefilling the box:\n\n```\napi=v1  // the version of the API to use\nwho=mo  // mo='me & others', m='only me', o='only others'\nsigners=first_email@example.com,second_email@example.com  // emails of 'signers' comma separated\nfrom_email=you@yourcompany.com  // email of the person sending the SignRequest\ndoc_url=https%3A%2F%2Fsignrequest.com%2Fstatic%2Fdemo%2FSignRequestDemoDocument.pdf  // the url where SignRequest can download the document (quoted)\n```\n\nExample resulting url:\n\n```\nhttps://signrequest.com/#/?api=v1&who=mo&signers=tech-support@signrequest.com&from_email=you@yourcompany.com&doc_url=https%3A%2F%2Fsignrequest.com%2Fstatic%2Fdemo%2FSignRequestDemoDocument.pdf\n```\n\nNote that you can also use prefill tags here by adding the parameter prefill_tags. The value should be Base64 encoded JSON, JavaScript example:\n\n```javascript\nbtoa(JSON.stringify([{external_id: 'customer_city', text: 'New York'}]));\n// the output can be used with the parameter:\n// prefill_tags=W3siZXh0ZXJuYWxfaWQiOiJjdXN0b21lcl9jaXR5IiwidGV4dCI6Ik5ldyBZb3JrIn1d\n```\n\n## SignRequest-js client\n\nAlthough we consider the library \"beta\" you can count on a stable API (semver). However, if you plan to use this please [contact us](https://signrequest.com/en/contact/) so we know your use case and can help you out where needed. We will open up the repository to the public when out of beta.\n\nTo use the SignRequest javascript library include the following in your page (npm and bower are coming when out of beta):\n\n```html\n<script src=\"https://cdn.signrequest.com/signrequest-js/v1/signrequest-js.min.js\"></script>\n```\nOr for async loading use:\n\n```html\n<script>\n!function(t,e,n,i){var s=function(e,n){t.SignRequest&&t.SignRequest.loaded||setTimeout(function(){t.SignRequest.init(e,n)},50)};t.SignRequest=t.SignRequest||{loaded:0,init:s};var o=\"https:\"==e.location.protocol?\"https://\":\"http://\",u=e.createElement(\"script\");u.async=!0;var c=e.scripts[0];u.src=o+\"cdn.signrequest.com/signrequest-js/v1/signrequest-js.min.js\",c.parentNode.insertBefore(u,c),t.SignRequest.init(n,i)}(window,document,{\n  // this initial configuration is optional, may also be undefined\n  subdomain: ''  // you could for example initialize the library to use a specific team subdomain here\n}, function (SignRequest) {\n  // this callback is optional, may also be undefined\n  // SignRequest library is loaded and also passed as first argument\n  // execute your code...\n});\n</script>\n```\n\nThe library uses [UMD](https://github.com/umdjs/umd) (Universal Module Definition).\n\nTo use a specific version (current is **1.0.5**) use for example: **cdn.signrequest.com/signrequest-js/v1/1.0.5/signrequest-js.min.js**.\n\n### Usage\n\n```javascript\n// same as the frontend API GET parameters, these are all optional\nvar conf = {\n    subdomain: '', // if you are using this for a specific team set the subdomain here\n    api: 'v1',\n    who: 'mo',\n    signers: 'first_email@example.com,second_email@example.com',\n    from_email: 'you@yourcompany.com',\n    close: true,  // close the popup when done? default: true\n    // or use next:\n    next: '',  // redirect to this url when done signing themselves,\n    frontend_id: '' // optional shared secret set on document to grant access to users even if they don't have access to team\n}\n// these are also optional, the popup will be centered in the window opening the popup\nvar popup_conf = {\n    width: 460,  // width of the popup in pixels, default 460\n    height: 600, // height of the popup in pixels, default the height of the window opening the popup\n}\n\n// to open a specific document first create a document using the REST API with your backend\n// be sure to also set the correct 'subdomain' in the configuration when you create a document for a specific team\nvar doc_uuid = 'the-uuid-of-the-document';\nSignRequest.browser.openPopupForDocUuid(doc_uuid, conf, popup_conf);\n\n// to create a document from a url\nvar doc_url = 'https://signrequest.com/static/demo/SignRequestDemoDocument.pdf'\nSignRequest.browser.openPopupForDocUrl(doc_url, conf, popup_conf);\n\n// to create a document from a template uuid\nvar template_uuid = 'the-uuid-of-the-template'\nSignRequest.browser.openPopupForTemplateUuid(template_uuid, conf, popup_conf);\n\n// to open a popup using custom params\nvar popup = SignRequest.browser.openPopup(conf, popup_conf);\n\n// if your document contains template tags / placeholders that have an 'external_id'\n// it is possible to 'prefill' these for a particular SignRequest by updating your conf object with for example:\nconf.prefill_tags = [{external_id: 'customer_city', text: 'New York'}];\n// Now all template tags with this external_id will be prefilled with 'New York'\n\n// all popup openers return an instance of the popup to which event callbacks can be registered (they can be chained)\n// the possible events are: 'opened', 'sent', 'signed', 'declined', 'finished', 'closed', 'any'\n// note that 'sent', 'finished' and 'closed' can be called fast after each other when the popup autocloses (close: true)\n// also when sending a SignRequest and the sender also need to sign you can receive the 'signed' or 'declined' event\n// after the 'sent' event (SignRequest created).\n// When the sender is done (sending and possibly siging) the 'finished' event is fired.\npopup = popup.on('closed', function (event_type, payload, event) {\n    // this would fire when the popup closes, you might want to update your page based on events like this\n    console.log(event_type, payload, event);\n})\n\n// shortcut to fire on all events ('any')\npopup.onAny(function (event_type, payload, event) {\n    // this would fire on all events\n    console.log(event_type, payload, event);\n})\n\n// to set a default configuration to use in all future calls for example for a team subdomain\nSignRequest.browser.setConfig({subdomain: 'the_subdomain_of_your_team'});\n\n// When creating a document for your users using our REST API and open that document in the popup in response to clicking a button\n// you might need to open the popup before you know the uuid of the document from your backend.\n// This to prevent popup blockers from kicking in when doing async work before we open a popup.\n// For this use case you can use the `openLoadingPopup` helper on click and use that already opened popup to load a document later.\n\n$('button#your_button').on('click', function () {  // using jQuery in the following example (not required for signrequest-js)\n    var popup = SignRequest.browser.openLoadingPopup();  // open a popup on button click right away\n    popup.onAny(function (event_type, payload, event) {\n        // all listeners created on the loading popup will also be registered on the popup events fired later after the we call\n        // SignRequest.browser.openPopupForDocUuid...\n        console.log('Event received: ' + event_type + ', payload: ' + JSON.stringify(payload);\n    });\n    // Async call some endpoint on your backend that creates a document using the REST API.\n    $.post('/your-endpoint-to-create-a-document', {some: 'data'}).then(function(response){\n        // instead of opening a new popup we use the one that is 'loading' as otherwise\n        // most browser popup blockers will block opening a new window here (the opening of the window comes too late after the user click).\n        // we assume here your endpoint returns the uuid of the document created in the response\n        SignRequest.browser.openPopupForDocUuid(response.document_uuid, conf, {sr_popup: popup});\n        // `{sr_popup: popup}` make the library use an existing popup instead of creating a new one\n    });\n});\n\nSignRequest.browser.openPopupForDocUrl('https://signrequest.com/static/demo/SignRequestDemoDocument.pdf');\n```\n\n### Sharing document with external users\n\nNormally a document stored within SignRequest would require the recipient to be a member of the document owner's team in order to gain access to the document. If you'd like to share a document outside of your team, you can [create a document](#operation/documents_create) while storing a shared secret on the `frontend_id` field. Then, using the SingRequest-js Client, you can add the `frontend_id` to the `conf` object when calling `openPopupForDocUuid` in order to grant any user presented with the signing popup access to the document.\n\n# Additional signing methods\n\n## Embed url\n\nNormally SignRequest will send the SignRequest email to signers containing the personal link to sign a document. This is how SignRequest validates an email address and is the preferred way. However, if your application requires a continuous flow (in a sales flow for example) it is possible to generate an `embed_url` and redirect a signer to that link. Combined with a `redirect_url` and/or `redirect_url_declined` a continuous flow can be achieved.\n\nDoing this moves the responsibility of identifying an email address / user to your application. This also shows in the signing log as SignRequest cannot guarantee that a document is signed by someone having access to an email address.\n\nTo generate the `embed_url` you need to declare the ID of the logged in user in YOUR application in the `embed_url_user_id` field. This ID will also show in the signing log.\n\nHere's a simple example:\n\n```json\n{\n    \"file_from_url\": \"https://signrequest.com/static/demo/SignRequestDemoDocument.pdf\",\n    \"from_email\": \"you@yourcompany.com\",\n    \"who\": \"mo\",\n    \"signers\": [\n        {\n           \"email\": \"you@yourcompany.com\",\n           \"order\": 1,\n           \"embed_url_user_id\": \"YOUR ID\"\n        }\n    ]\n}\n```\n\nThe generated `embed_url` can only be used until the document is signed. Note that it is perfectly fine to combine signers with and without a generated `embed_url`. The `order` field also behaves as you would expect. For example, if the first signer (order = 0) has an `embed_url` generated and the second (order = 1) not, the second signer will only receive the SignRequest email when the first one has signed.\n\nWhen using this `embed_url` in an `iframe`, you can add any of the following url parameters to hide some elements in the header: `&hide_login=1` (hide the login button), `&hide_cancel=1` (hide the cancel link), `&hide_decline=1` (hide the option to decline), `&hide_logo=1` (hide the logo) and `&hide_title=1` (hide the document title in the header). Be aware that the `embed_url` may already contain other url parameters. Also note that hiding the login button does not disable to login prompt for signers that already have a SignRequest account. This cannot be disabled.\n\nIf you also want to disable all other SignRequest emails, see [Disable all SignRequest email events](#section/Events/Disable-all-SignRequest-email-events).\n\n## In person signing\n\nIn some cases your application might want to generate one url for both the sender of the document and the receiver to sign a document after each other in person.\n\nThis can be achieved by this signer configuration example:\n\n```json\n{\n    \"file_from_url\": \"https://signrequest.com/static/demo/SignRequestDemoDocument.pdf\",\n    \"from_email\": \"you@yourcompany.com\",\n    \"who\": \"mo\",\n    \"signers\": [\n        {\n           \"email\": \"you@yourcompany.com\",\n           \"order\": 1,\n           \"embed_url_user_id\": \"your ID\",\n        },\n        {\n            \"email\": \"tech-support@signrequest.com\",\n            \"order\": 2,\n            \"in_person\": true\n        }\n    ]\n}\n```\n\nThis way you can redirect the user to the `embed_url` of the sender. After the sender has signed they will be redirected to the next `in_person` signer.\n\n## Approve only\nIf you have contacts that you don't need a signature from, but want their approval, you can use the `approve_only` option for the signer.\n\nIn this case SignRequest will add this approval to the signing log, but it will be easier for the user / signer to quickly approve the document. It also has the added benefit that there will not be a visible signature on the document of that person.\n\n## Notify only\nIf you have contacts that  do not need to take any action on the document, you can use the `notify_only` option for the signer.  The contact will receive an email during every step of this SignRequest.  He or she will receive an email when the document is first sent, when it is viewed, when it is signed by a signer, and finalized completely.  This contact will also receive a copy of the final document and signing log as attachments to the \"document signed\" email at the end.\n\n## Copy only\nIf you have contacts that only need to receive a copy of the document, but does not need to sign, you can set `needs_to_sign` to `false` for the signer. This contact will simply receive a copy of the final document and signing log as attachments to the \"document signed\" email at the end.\n\n# Integration Partners\n\n## Salesforce\n\nThe most straight forward way to integrate Salesforce with SignRequest is to use our managed package.\n\nNormally you would use the SignRequest buttons provided in the managed package to create SignRequest documents from Salesforce but if you want to skip that step and create SignRequests using the API (but still sync documents to Salesforce) you can add the following data to a `signrequest`:\n\n```json\n\"integration_data\": {\n    \"object_type\": \"API NAME OF THE (S)OBJECT, e.g. 'Opportunity' or 'CustomObject__c'\",\n    \"uid\": \"UID OF THE SALESFORCE USER (NOT UUID), e.g. 'https:\\\\/\\\\/login.salesforce.com\\\\/id\\\\/00D24000000pMDZEA2\\\\/005240000048zB0AAI'\",\n    \"object_id\": \"OBJECT ID, e.g. 0062400000MaeNv\"\n},\n\"integration\": \"salesforce\"\n```\n\nCaveat: The user of the `from_email` needs to be a member of the Team that created the `signrequest`, and the user needs to have a SignRequest account using Salesforce OAuth.\n\n## Zapier\n\nDoes your app integrate with Zapier? Chances are your digital signatures are just a few clicks away! \nCheckout our Zapier integration here: https://signrequest.com/en/digital-electronic-signatures-with-zapier/\n\n## Becoming an integration partner\n\nIf your application requires to create Teams and act on behalf of them you need to become an integration partner. This only grants you access to resources created by your application of the third party Team.\n\nTeams can be created and updated on the [Teams resource](#tag/teams).\n\nPlease [contact us](https://signrequest.com/en/contact/) to learn more.\n\n## OAuth2 Authorization Framework\n\nSignRequest allows partner applications to use the API on behalf of SignRequest users using OAuth2. If you need this functionality you can [create an application here](/api/v1/oauth2/applications/) (choose Client type: Confidential, Authorization grant type: Authorization code) and [contact us](https://signrequest.com/en/contact/) if you need any help. The OAuth2 framework is [rfc-compliant](https://tools.ietf.org/html/rfc6749).\n\nOAuth2 endpoints:\n\n- https://signrequest.com/api/v1/oauth2/authorize/ Get authorization code  \nGET params: client_id, scope(s)[=we currently only support the 'read', 'write' scopes], response_type[=code], state[=your_random_state_string], redirect_uri[=if not provided the first of your application is used]\n- https://signrequest.com/api/v1/oauth2/token/ Request a new (refresh) token  \nPOST params: code[=the client code], grant_type[=authorization_code], redirect_uri, client_id, client_secret[=required when using the 'confidential' client type]\n- https://signrequest.com/api/v1/oauth2/revoke_token/ Revoke a token  \nPOST params: token[=token to revoke], token_type_hint[=optional, designating either 'access_token' or 'refresh_token'.\n\nUse tokens with the `Authorization: Bearer YOUR_TOKEN_HERE` header in your requests. To remove your authorized applications/tokens during development [go here](/api/v1/oauth2/authorized_tokens/). [Contact us](https://signrequest.com/en/contact/) if you want your logo added to the consent screen.\n\n\n# Client libraries\n\nWe have client libraries for the following languages. Is your language missing? Let us know!\n\n- Python: https://github.com/SignRequest/signrequest-python-client  \n- Ruby: https://github.com/SignRequest/signrequest-ruby-client\n- Node.js (Javascript):  https://github.com/SignRequest/signrequest-node-client\n- C# (.NET): https://github.com/SignRequest/signrequest-csharp-client\n- PHP: https://github.com/SignRequest/signrequest-php-client\n- Event receiver (Python server): https://github.com/SignRequest/signrequest-event-receiver  \n\nWe also offer two example repositories using Node.js and Python:\n\n- Node Example: https://github.com/SignRequest/signrequest-Node-example\n- Python Example: https://github.com/SignRequest/signrequest-Python-example\n\n### More coming soon\nDocumentation about more advanced usage of the SignRequest API and language specific client libraries is coming soon.\n\nFeel free to contact us at tech-support@signrequest.com for any questions or feature requests.\n",
    "termsOfService": "https://signrequest.com/r/terms",
    "contact": {
      "email": "tech-support@signrequest.com"
    },
    "x-logo": {
      "url": "https://signrequest.com/images/logo-padded.png",
      "altText": "SignRequest"
    },
    "version": "v1"
  },
  "security": [
    {
      "Token": []
    }
  ],
  "paths": {
    "/api-tokens/": {
      "get": {
        "operationId": "api-tokens_list",
        "summary": "Retrieve a list of API tokens",
        "description": "",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/AuthToken"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "api-tokens"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.ApiTokensApi();\n\nvar opts = {\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.apiTokensList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\ApiTokensApi(new GuzzleHttp\\Client(), $config);\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->apiTokensList($page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.ApiTokensApi()\n\napi_response = api_instance.api_tokens_list(page=1, limit=20)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new ApiTokensApi();\nvar page = 1;\nvar limit = 20;\n\nInlineResponse200 result = apiInstance.ApiTokensList(page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::ApiTokensApi.new\n\nopts = {\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.api_tokens_list(opts)\n"
          }
        ]
      },
      "parameters": []
    },
    "/audit-events/": {
      "get": {
        "operationId": "audit-events_list",
        "summary": "Retrieve a list of AuditEvents",
        "description": "",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "user_email",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user_ip",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "event_type",
            "in": "query",
            "description": "`login_failed`: Login failed, `login_successful`: Login successful, `password_reset_request_sent`: Password reset request sent, `password_reset_request_error`: Password reset request error",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "`success`: Success, `error`: Error",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestamp__date__lt",
            "in": "query",
            "description": "Date format YYYY-MM-DD",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestamp__date__lte",
            "in": "query",
            "description": "Date format YYYY-MM-DD",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestamp__date__gt",
            "in": "query",
            "description": "Date format YYYY-MM-DD",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestamp__date__gte",
            "in": "query",
            "description": "Date format YYYY-MM-DD",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/AuditEvent"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "audit-events"
        ]
      },
      "parameters": []
    },
    "/document-attachments/": {
      "get": {
        "operationId": "document-attachments_list",
        "summary": "Retrieve a list of Document Attachments",
        "description": "",
        "parameters": [
          {
            "name": "document__uuid",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__external_id",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "created",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DocumentAttachment"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "document-attachments"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentAttachmentsApi();\n\nvar opts = {\n  'document__uuid': \"document__uuid_example\",\n  'document__external_id': \"document__external_id_example\",\n  'created': \"created_example\",\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.documentAttachmentsList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentAttachmentsApi(new GuzzleHttp\\Client(), $config);\n\n$document__uuid = \"document__uuid_example\";\n$document__external_id = \"document__external_id_example\";\n$created = \"created_example\";\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->documentAttachmentsList($document__uuid, $document__external_id, $created, $page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentAttachmentsApi()\n\napi_instance.document_attachments_list(page=1, limit=20)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentAttachmentsApi();\nvar documentUuid = \"documentUuid_example\";\nvar documentExternalId = \"documentExternalId_example\";\nvar created = \"created_example\";\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2001 result = apiInstance.DocumentAttachmentsList(documentUuid, documentExternalId, created, page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentAttachmentsApi.new\n\nopts = {\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.document_attachments_list(opts)\n"
          }
        ]
      },
      "post": {
        "operationId": "document-attachments_create",
        "summary": "Create a Document Attachment",
        "description": "",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentAttachment"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentAttachment"
                }
              }
            }
          }
        },
        "tags": [
          "document-attachments"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentAttachmentsApi();\n\nvar data = new SignrequestClient.DocumentAttachment();\ndata.file_from_url = 'https://example.com/file.pdf';\ndata.document = 'https://example.com/doc';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.documentAttachmentsCreate(data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentAttachmentsApi(new GuzzleHttp\\Client(), $config);\n$data = new \\SignRequest\\Model\\DocumentAttachment();\n$data->setFileFromUrl('https://example.com/file.pdf');\n$data->setDocument('https://example.com/doc');\n\n$result = $apiInstance->documentAttachmentsCreate($data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentAttachmentsApi()\ndata = signrequest_client.DocumentAttachment(\n    file_from_url='https://example.com/file.pdf',\n    document='https://example.com/doc'\n)\n\napi_response = api_instance.document_attachments_create(data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentAttachmentsApi();\nvar data = new DocumentAttachment();\ndata.FileFromUrl = \"https://example.com/file.pdf\";\ndata.Document = \"https://example.com/doc\";\n\nDocumentAttachment result = apiInstance.DocumentAttachmentsCreate(data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentAttachmentsApi.new\ndata = SignRequestClient::DocumentAttachment.new\ndata.file_from_url = 'https://example.com/file.pdf'\ndata.document = 'https://example.com/doc'\n\nresult = api_instance.document_attachments_create(data)\n"
          }
        ]
      },
      "parameters": []
    },
    "/document-attachments/{uuid}/": {
      "get": {
        "operationId": "document-attachments_read",
        "summary": "Retrieve a Document Attachment",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentAttachment"
                }
              }
            }
          }
        },
        "tags": [
          "document-attachments"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentAttachmentsApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.documentAttachmentsRead(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentAttachmentsApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->documentAttachmentsRead($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentAttachmentsApi()\nuuid = 'uuid_example'\n\napi_response = api_instance.document_attachments_read(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentAttachmentsApi();\nvar uuid = \"uuid_example\";\n\nDocumentAttachment result = apiInstance.DocumentAttachmentsRead(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentAttachmentsApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.document_attachments_read(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/documents-search/": {
      "get": {
        "operationId": "documents-search_list",
        "summary": "Search documents",
        "description": "Search interface for fast (autocomplete) searching of documents.\n\nThis can be useful to have your users search for a document in your interface.\n\nDocument names are tokenized on whitespace, hyphens and underscores to also match partial document names.\n\n*Normal search:*\n\n- ?**q**={{query}}\n\n*Autocomplete search:*\n\n- ?**autocomplete**={{partial query}}\n\n*Search in document name:*\n\n- ?**name**={{query}}\n\n*Available (extra) filters:*\n\n- ?**subdomain**={{ team_subdomain }} or use this endpoint with team_subdomain.signrequest.com\n(when not provided only personal documents are shown)\n- ?**signer_emails**={{ signer@email.com }} (will filter documents that an email needed to sign/approve)\n- ?**status**={{ si }}\n- ?**who**={{ mo }}\n\nTo include multiple values for a filter field separate the values with a pipe (|).\nFor example to only search for completed documents use **status=se|vi** (sent and viewed).\n\n*Pagination:*\n\n- ?**page**={{ page_number: default 1 }}\n- ?**limit**={{ limit results: default 10, max 100 }}\n\n*Format:*\n\nBy default json is returned, to export data as csv or xls use the format parameter.\n\n- ?**format**=csv\n- ?**format**=xls\n\nFor csv and xls the data can also be exported with each signer on a separate row. In this mode also the signer\ninputs that have an *external_id* specified on a tag will be exported. All external_id's found will be exported as\ncolumns. To use this mode add the **signer_data** parameter.\n\n- ?**format**=csv&**signer_data**=1\n- ?**format**=xls&**signer_data**=1\n\nNote that all documents are only ordered by **created** (newest first) when **q**, **autocomplete** or **name** are\nnot used, else they are ordered by the strenght of the match.",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "q",
            "in": "query",
            "description": "Normal search query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "autocomplete",
            "in": "query",
            "description": "Partial search query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Document name",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "subdomain",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signer_emails",
            "in": "query",
            "description": "Email needed to sign/approve",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "`co`: converting, `ne`: new, `se`: sent, `vi`: viewed, `si`: signed, `do`: downloaded, `sd`: signed and downloaded, `ca`: cancelled, `de`: declined, `ec`: error converting, `es`: error sending, `xp`: expired",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "who",
            "in": "query",
            "description": "`m`: only me, `mo`: me and others, `o`: only others",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Export format, can be `json` (default), `csv`, or `xls`",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signer_data",
            "in": "query",
            "description": "Set to `1` to export with each signer on a separate row",
            "schema": {
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DocumentSearchDirect"
                      }
                    }
                  }
                }
              },
              "text/csv": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DocumentSearchDirect"
                      }
                    }
                  }
                }
              },
              "application/vnd.ms-excel": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DocumentSearchDirect"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "documents-search"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentsSearchApi();\n\nvar opts = {\n  'page': 1,\n  'limit': 20,\n  'q': 'q_example',\n  'autocomplete': 'autocomplete_example',\n  'name': 'name_example',\n  'subdomain': 'subdomain_example',\n  'signer_emails': 'someone@example.com',\n  'status': 'si',\n  'who': 'o',\n  'format': 'json',\n  'signer_data': 1\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.documentsSearchList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentsSearchApi(new GuzzleHttp\\Client(), $config);\n$page = 1;\n$limit = 20;\n$q = \"q_example\";\n$autocomplete = \"autocomplete_example\";\n$name = \"name_example\";\n$subdomain = \"subdomain_example\";\n$signer_emails = \"someone@example.com\";\n$status = \"si\";\n$who = \"o\";\n$format = \"json\";\n$signer_data = 1;\n\n$result = $apiInstance->documentsSearchList($page, $limit, $q, $autocomplete, $name, $subdomain, $signer_emails, $status, $who, $format, $signer_data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentsSearchApi()\n\napi_response = api_instance.documents_search_list(\n    page=1,\n    limit=20,\n    q='q_example',\n    autocomplete='autocomplete_example',\n    name='name_example',\n    subdomain='subdomain_example',\n    signer_emails='someone@example.com',\n    status='si',\n    who='o',\n    format='json',\n    signer_data=1\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentsSearchApi();\nvar page = 1;\nvar limit = 20;\nvar q = \"q_example\";\nvar autocomplete = \"autocomplete_example\";\nvar name = \"name_example\";\nvar subdomain = \"someone@example.com\";\nvar signerEmails = \"signerEmails_example\";\nvar status = \"si\";\nvar who = \"o\";\nvar format = \"json\";\nvar signerData = 1;\n\nInlineResponse2002 result = apiInstance.DocumentsSearchList(page, limit, q, autocomplete, name, subdomain,\n    signerEmails, status, who, format, signerData);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentsSearchApi.new\n\nopts = {\n  page: 1,\n  limit: 20,\n  q: 'q_example',\n  autocomplete: 'autocomplete_example',\n  name: 'name_example',\n  subdomain: 'subdomain_example',\n  signer_emails: 'someone@example.com',\n  status: 'si',\n  who: 'o',\n  format: 'json',\n  signer_data: 1\n}\n\nresult = api_instance.documents_search_list(opts)\n"
          }
        ]
      },
      "parameters": []
    },
    "/documents/": {
      "get": {
        "operationId": "documents_list",
        "summary": "Retrieve a list of Documents",
        "description": "",
        "parameters": [
          {
            "name": "external_id",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signrequest__who",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signrequest__from_email",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user__email",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user__first_name",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user__last_name",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "created",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "modified",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Document"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "documents"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentsApi();\n\nvar opts = {\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.documentsList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentsApi(new GuzzleHttp\\Client(), $config);\n$external_id = \"external_id_example\";\n$signrequest__who = \"signrequest__who_example\";\n$signrequest__from_email = \"signrequest__from_email_example\";\n$status = \"status_example\";\n$user__email = \"user__email_example\";\n$user__first_name = \"user__first_name_example\";\n$user__last_name = \"user__last_name_example\";\n$created = \"created_example\";\n$modified = \"modified_example\";\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->documentsList($external_id, $signrequest__who, $signrequest__from_email, $status,\n    $user__email, $user__first_name, $user__last_name, $created, $modified, $page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentsApi()\n\napi_response = api_instance.documents_list(page=1, limit=20)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentsApi();\nvar externalId = \"externalId_example\";\nvar signrequestWho = \"signrequestWho_example\";\nvar signrequestFromEmail = \"signrequestFromEmail_example\";\nvar status = \"status_example\";\nvar userEmail = \"userEmail_example\";\nvar userFirstName = \"userFirstName_example\";\nvar userLastName = \"userLastName_example\";\nvar created = \"created_example\";\nvar modified = \"modified_example\";\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2003 result = apiInstance.DocumentsList(externalId, signrequestWho, signrequestFromEmail, status,\n    userEmail, userFirstName, userLastName, created, modified, page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentsApi.new\n\nopts = {\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.documents_list(opts)\n"
          }
        ]
      },
      "post": {
        "operationId": "documents_create",
        "summary": "Create a Document",
        "description": "",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Document"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          }
        },
        "tags": [
          "documents"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentsApi();\n\nvar data = new SignrequestClient.Document(); // Document |\ndata.file_from_url = 'https://example.com/file.pdf';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\napiInstance.documentsCreate(data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentsApi(new GuzzleHttp\\Client(), $config);\n$data = new \\SignRequest\\Model\\Document();\n$data->setFileFromUrl('https://example.com/file.pdf');\n\n$result = $apiInstance->documentsCreate($data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentsApi()\ndata = signrequest_client.Document(\n    file_from_url='https://example.com/file.pdf'\n)\n\napi_response = api_instance.documents_create(data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentsApi();\nvar data = new Document();\ndata.FileFromUrl = \"https://example.com/file.pdf\";\n\nDocument result = apiInstance.DocumentsCreate(data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentsApi.new\ndata = SignRequestClient::Document.new\ndata.file_from_url = 'https://example.com/file.pdf'\n\nresult = api_instance.documents_create(data)\n"
          }
        ]
      },
      "parameters": []
    },
    "/documents/{uuid}/": {
      "get": {
        "operationId": "documents_read",
        "summary": "Retrieve a Document",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Document"
                }
              }
            }
          }
        },
        "tags": [
          "documents"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentsApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.documentsRead(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentsApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->documentsRead($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentsApi()\nuuid = 'uuid_example'\n\napi_response = api_instance.documents_read(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentsApi();\nvar uuid = \"uuid_example\";\n\nDocument result = apiInstance.DocumentsRead(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentsApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.documents_read(uuid)\n"
          }
        ]
      },
      "delete": {
        "operationId": "documents_delete",
        "summary": "Delete a Document",
        "description": "",
        "responses": {
          "204": {
            "description": ""
          }
        },
        "tags": [
          "documents"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.DocumentsApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully.');\n  }\n};\n\napiInstance.documentsDelete(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\DocumentsApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$apiInstance->documentsDelete($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.DocumentsApi()\nuuid = 'uuid_example'\n\napi_instance.documents_delete(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new DocumentsApi();\nvar uuid = \"uuid_example\";\n\napiInstance.DocumentsDelete(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::DocumentsApi.new\nuuid = 'uuid_example'\n\napi_instance.documents_delete(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/events/": {
      "get": {
        "operationId": "events_list",
        "summary": "Retrieve a list of Events",
        "description": "",
        "parameters": [
          {
            "name": "document__uuid",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__external_id",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__signrequest__who",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__signrequest__from_email",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__status",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__user__email",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__user__first_name",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "document__user__last_name",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "delivered",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "delivered_on",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestamp",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "event_type",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Event"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "events"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.EventsApi();\n\nvar opts = {\n  'document__uuid': \"document__uuid_example\",\n  'document__external_id': \"document__external_id_example\",\n  'document__signrequest__who': \"document__signrequest__who_example\",\n  'document__signrequest__from_email': \"document__signrequest__from_email_example\",\n  'document__status': \"document__status_example\",\n  'document__user__email': \"document__user__email_example\",\n  'document__user__first_name': \"document__user__first_name_example\",\n  'document__user__last_name': \"document__user__last_name_example\",\n  'delivered': \"delivered_example\",\n  'delivered_on': \"delivered_on_example\",\n  'timestamp': \"timestamp_example\",\n  'status': \"status_example\",\n  'event_type': \"event_type_example\",\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.eventsList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\EventsApi(new GuzzleHttp\\Client(), $config);\n$document__uuid = \"document__uuid_example\";\n$document__external_id = \"document__external_id_example\";\n$document__signrequest__who = \"document__signrequest__who_example\";\n$document__signrequest__from_email = \"document__signrequest__from_email_example\";\n$document__status = \"document__status_example\";\n$document__user__email = \"document__user__email_example\";\n$document__user__first_name = \"document__user__first_name_example\";\n$document__user__last_name = \"document__user__last_name_example\";\n$delivered = \"delivered_example\";\n$delivered_on = \"delivered_on_example\";\n$timestamp = \"timestamp_example\";\n$status = \"status_example\";\n$event_type = \"event_type_example\";\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->eventsList($document__uuid, $document__external_id, $document__signrequest__who,\n    $document__signrequest__from_email, $document__status, $document__user__email, $document__user__first_name,\n    $document__user__last_name, $delivered, $delivered_on, $timestamp, $status, $event_type, $page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.EventsApi()\n\napi_response = api_instance.events_list(\n    document__uuid='document__uuid_example',\n    document__external_id='document__external_id_example',\n    document__signrequest__who='document__signrequest__who_example',\n    document__signrequest__from_email='document__signrequest__from_email_example',\n    document__status='document__status_example',\n    document__user__email='document__user__email_example',\n    document__user__first_name='document__user__first_name_example',\n    document__user__last_name='document__user__last_name_example',\n    delivered='delivered_example',\n    delivered_on='delivered_on_example',\n    timestamp='timestamp_example',\n    status='status_example',\n    event_type='event_type_example',\n    page=1,\n    limit=20\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new EventsApi();\nvar documentUuid = \"documentUuid_example\";\nvar documentExternalId = \"documentExternalId_example\";\nvar documentSignrequestWho = \"documentSignrequestWho_example\";\nvar documentSignrequestFromEmail = \"documentSignrequestFromEmail_example\";\nvar documentStatus = \"documentStatus_example\";\nvar documentUserEmail = \"documentUserEmail_example\";\nvar documentUserFirstName = \"documentUserFirstName_example\";\nvar documentUserLastName = \"documentUserLastName_example\";\nvar delivered = \"delivered_example\";\nvar deliveredOn = \"deliveredOn_example\";\nvar timestamp = \"timestamp_example\";\nvar status = \"status_example\";\nvar eventType = \"eventType_example\";\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2004 result = apiInstance.EventsList(documentUuid, documentExternalId, documentSignrequestWho,\n    documentSignrequestFromEmail, documentStatus, documentUserEmail, documentUserFirstName, documentUserLastName, delivered, deliveredOn, timestamp, status, eventType, page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::EventsApi.new\n\nopts = {\n  document__uuid: 'document__uuid_example',\n  document__external_id: 'document__external_id_example',\n  document__signrequest__who: 'document__signrequest__who_example',\n  document__signrequest__from_email: 'document__signrequest__from_email_example',\n  document__status: 'document__status_example',\n  document__user__email: 'document__user__email_example',\n  document__user__first_name: 'document__user__first_name_example',\n  document__user__last_name: 'document__user__last_name_example',\n  delivered: 'delivered_example',\n  delivered_on: 'delivered_on_example',\n  timestamp: 'timestamp_example',\n  status: 'status_example',\n  event_type: 'event_type_example',\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.events_list(opts)\n"
          }
        ]
      },
      "parameters": []
    },
    "/events/{uuid}/": {
      "get": {
        "operationId": "events_read",
        "summary": "Retrieve an Event",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Event"
                }
              }
            }
          }
        },
        "tags": [
          "events"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.EventsApi();\n\nvar id = 56;\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.eventsRead(id, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\EventsApi(new GuzzleHttp\\Client(), $config);\n$id = 56;\n\n$result = $apiInstance->eventsRead($id);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.EventsApi()\nid = 56\n\napi_response = api_instance.events_read(id)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new EventsApi();\nvar id = 56;\n\nModelEvent result = apiInstance.EventsRead(id);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::EventsApi.new\nid = 56\n\nresult = api_instance.events_read(id)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/signrequest-quick-create/": {
      "post": {
        "operationId": "signrequest-quick-create_create",
        "summary": "Quick create a SignRequest",
        "description": "",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignRequestQuickCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignRequestQuickCreate"
                }
              }
            }
          }
        },
        "tags": [
          "signrequest-quick-create"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.SignrequestQuickCreateApi();\n\nvar data = new SignrequestClient.SignRequestQuickCreate();\ndata.signers = [\n  {\n    email: 'signer1@example.com'\n  }\n];\n\ndata.file_from_url = 'https://example.com/file.pdf';\ndata.from_email = 'you@example.com';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.signrequestQuickCreateCreate(data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\SignrequestQuickCreateApi(new GuzzleHttp\\Client(), $config);\n$data = new \\SignRequest\\Model\\SignRequestQuickCreate();\n$signer = new \\SignRequest\\Model\\Signer();\n$signer->setEmail('signer1@example.com');\n$data->setSigners(array($signer));\n$data->setFileFromUrl('https://example.com/file.pdf');\n$data->setFromEmail('you@example.com');\n\n$result = $apiInstance->signrequestQuickCreateCreate($data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.SignrequestQuickCreateApi()\ndata = signrequest_client.SignRequestQuickCreate(\n    signers=[\n      {\n        'email': 'signer1@example.com'\n      }\n    ],\n    file_from_url='https://example.com/file.pdf',\n    from_email='you@example.com'\n)\n\napi_response = api_instance.signrequest_quick_create_create(data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new SignrequestQuickCreateApi();\nvar data = new SignRequestQuickCreate(\n    FromEmail: \"you@example.com\",\n    Signers: new List<Signer>\n    {\n        new Signer(Email: \"signer1@example.com\")\n    },\n    FileFromUrl: \"https://docs.google.com/document/d/1-gzqym9clQ1a193JGocXUeIX92cqPINBHOBeGxbDASw/edit\"\n);\n\nSignRequestQuickCreate result = apiInstance.SignrequestQuickCreateCreate(data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::SignrequestQuickCreateApi.new\ndata = SignRequestClient::SignRequestQuickCreate.new\n\ndata.signers = [\n  {\n    email: 'signer1@example.com'\n  }\n]\n\ndata.file_from_url = 'https://example.com/file.pdf'\ndata.from_email = 'you@example.com'\n\nresult = api_instance.signrequest_quick_create_create(data)\n"
          }
        ]
      },
      "parameters": []
    },
    "/signrequests/": {
      "get": {
        "operationId": "signrequests_list",
        "summary": "Retrieve a list of SignRequests",
        "description": "",
        "parameters": [
          {
            "name": "who",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "from_email",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/SignRequest"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "signrequests"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.SignrequestsApi();\n\nvar opts = { \n  'who': 'o', \n  'from_email': 'someone@example.com', \n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.signrequestsList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\SignrequestsApi(new GuzzleHttp\\Client(), $config);\n$who = \"o\";\n$from_email = \"someone@example.com\";\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->signrequestsList($who, $from_email, $page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.SignrequestsApi()\n\napi_response = api_instance.signrequests_list(\n    who='o',\n    from_email='someone@example.com',\n    page=1,\n    limit=20\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new SignrequestsApi();\nvar who = \"o\";\nvar fromEmail = \"someone@example.com\";\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2005 result = apiInstance.SignrequestsList(who, fromEmail, page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::SignrequestsApi.new\n\nopts = {\n  who: 'o',\n  from_email: 'someone@example.com',\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.signrequests_list(opts)\n"
          }
        ]
      },
      "post": {
        "operationId": "signrequests_create",
        "summary": "Create a SignRequest",
        "description": "",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignRequest"
                }
              }
            }
          }
        },
        "tags": [
          "signrequests"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.SignrequestsApi();\n\nvar data = new SignrequestClient.SignRequest();\ndata.signers = [\n  {\n    email: 'signer1@example.com'\n  }\n];\n\ndata.document = 'https://example.com/doc';\ndata.from_email = 'you@example.com';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.signrequestsCreate(data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\SignrequestsApi(new GuzzleHttp\\Client(), $config);\n$data = new \\SignRequest\\Model\\SignRequest();\n\n$signer = new \\SignRequest\\Model\\Signer();\n$signer->setEmail('signer1@example.com');\n\n$data->setSigners(array($signer));\n$data->setDocument('https://example.com/doc');\n$data->setFromEmail('you@example.com');\n\n$result = $apiInstance->signrequestsCreate($data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.SignrequestsApi()\ndata = signrequest_client.SignRequest(\n    document='https://example.com/doc',\n    signers=[\n        {\n            'email': 'signer1@example.com',\n        }\n    ],\n    from_email='you@example.com'\n)\n\napi_response = api_instance.signrequests_create(data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new SignrequestsApi();\nvar data = new SignRequest.Model.SignRequest(\n    Signers: new List<Signer>\n    {\n        new Signer(Email: \"signer1@example.com\")\n    },\n    FromEmail: \"you@example.com\",\n    Document: \"https://example.com/doc\"\n);\n\nSignRequest.Model.SignRequest result = apiInstance.SignrequestsCreate(data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::SignrequestsApi.new\ndata = SignRequestClient::SignRequest.new\n\ndata.signers = [\n  {\n    email: 'signer1@example.com'\n  }\n]\n\ndata.document = 'https://example.com/doc'\ndata.from_email = 'you@example.com'\n\nresult = api_instance.signrequests_create(data)\n"
          }
        ]
      },
      "parameters": []
    },
    "/signrequests/{uuid}/": {
      "get": {
        "operationId": "signrequests_read",
        "summary": "Retrieve a SignRequest",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignRequest"
                }
              }
            }
          }
        },
        "tags": [
          "signrequests"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.SignrequestsApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.signrequestsRead(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\SignrequestsApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->signrequestsRead($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.SignrequestsApi()\nuuid = 'uuid_example'\n\napi_response = api_instance.signrequests_read(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new SignrequestsApi();\nvar uuid = \"uuid_example\";\n\nSignRequest result = apiInstance.SignrequestsRead(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::SignrequestsApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.signrequests_read(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/signrequests/{uuid}/cancel_signrequest/": {
      "post": {
        "operationId": "signrequests_cancel_signrequest",
        "summary": "Cancel a SignRequest",
        "description": "",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "detail",
                    "cancelled"
                  ],
                  "type": "object",
                  "properties": {
                    "detail": {
                      "type": "string",
                      "enum": [
                        "OK"
                      ]
                    },
                    "cancelled": {
                      "type": "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "signrequests"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.SignrequestsApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.signrequestsCancelSignrequest(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\SignrequestsApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->signrequestsCancelSignrequest($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.SignrequestsApi()\nuuid = 'uuid_example'\n\napi_instance.signrequests_cancel_signrequest(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new SignrequestsApi();\nvar uuid = \"uuid_example\";\n\nInlineResponse201 result = apiInstance.SignrequestsCancelSignrequest(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::SignrequestsApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.signrequests_cancel_signrequest(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/signrequests/{uuid}/forward_signer/": {
      "post": {
        "operationId": "signrequests_forward_signer",
        "summary": "Forward a SignRequest to a different signer by email",
        "description": "",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ForwardSigner"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Updated SignRequest instance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignRequest"
                }
              }
            }
          },
          "400": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "errors": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "signrequests"
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/signrequests/{uuid}/resend_signrequest_email/": {
      "post": {
        "operationId": "signrequests_resend_signrequest_email",
        "summary": "Resend a SignRequest",
        "description": "",
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "detail"
                  ],
                  "type": "object",
                  "properties": {
                    "detail": {
                      "type": "string",
                      "enum": [
                        "OK"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "signrequests"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.SignrequestsApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.signrequestsResendSignrequestEmail(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\SignrequestsApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->signrequestsResendSignrequestEmail($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.SignrequestsApi()\nuuid = 'uuid_example'\n\napi_instance.signrequests_resend_signrequest_email(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new SignrequestsApi();\nvar uuid = \"uuid_example\";\n\nInlineResponse2011 result = apiInstance.SignrequestsResendSignrequestEmail(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::SignrequestsApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.signrequests_resend_signrequest_email(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/team-members/": {
      "get": {
        "operationId": "team-members_list",
        "summary": "Retrieve a list of Team Members",
        "description": "",
        "parameters": [
          {
            "name": "is_active",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "is_owner",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "is_admin",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user__email",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user__first_name",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "user__last_name",
            "in": "query",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/TeamMember"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "team-members"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamMembersApi();\n\nvar opts = { \n  'is_active': 'true', \n  'is_owner': 'true', \n  'is_admin': 'true', \n  'user__email': 'someone@example.com', \n  'user__first_name': 'user__first_name_example', \n  'user__last_name': 'user__last_name_example', \n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.teamMembersList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamMembersApi(new GuzzleHttp\\Client(), $config);\n$is_active = \"true\";\n$is_owner = \"true\";\n$is_admin = \"true\";\n$user__email = \"someone@example.com\";\n$user__first_name = \"user__first_name_example\";\n$user__last_name = \"user__last_name_example\";\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->teamMembersList($is_active, $is_owner, $is_admin, $user__email, $user__first_name, $user__last_name, $page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TeamMembersApi()\n\napi_response = api_instance.team_members_list(\n    is_active='true',\n    is_owner='true',\n    is_admin='true',\n    user__email='someone@example.com',\n    user__first_name='user__first_name_example',\n    user__last_name='user__last_name_example',\n    page=1,\n    limit=20\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamMembersApi();\nvar isActive = \"true\";\nvar isOwner = \"true\";\nvar isAdmin = \"true\";\nvar userEmail = \"someone@example.com\";\nvar userFirstName = \"userFirstName_example\";\nvar userLastName = \"userLastName_example\";\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2006 result = apiInstance.TeamMembersList(isActive, isOwner, isAdmin, userEmail, userFirstName,\n    userLastName, page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamMembersApi.new\n\nopts = {\n  is_active: 'true',\n  is_owner: 'true',\n  is_admin: 'true',\n  user__email: 'someone@example.com',\n  user__first_name: 'user__first_name_example',\n  user__last_name: 'user__last_name_example',\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.team_members_list(opts)\n"
          }
        ]
      },
      "parameters": []
    },
    "/team-members/{uuid}/": {
      "get": {
        "operationId": "team-members_read",
        "summary": "Retrieve a Team Member",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamMember"
                }
              }
            }
          }
        },
        "tags": [
          "team-members"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamMembersApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.teamMembersRead(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamMembersApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->teamMembersRead($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "api_instance = signrequest_client.TeamMembersApi()\nuuid = 'uuid_example'\n\napi_response = api_instance.team_members_read(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamMembersApi();\nvar uuid = \"uuid_example\";\n\nTeamMember result = apiInstance.TeamMembersRead(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamMembersApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.team_members_read(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/teams/": {
      "get": {
        "operationId": "teams_list",
        "summary": "Retrieve a list of Teams",
        "description": "Required fields are **name** and **subdomain** where the subdomain is globally unique.\nUse **POST** to create a Team.\nTo update a field on a Team use **PATCH**.\n\nTo use the API on behalf of a particular team change the endpoint to:\n*https://**{{ subdomain }}**.signrequest.com/api/v1/...*\n\nTo invite new team members you can use **POST**\n{\"email\":\"**email-of-member-to-invite@example.com**\",\"is_admin\":false,\"is_owner\":false} to:\n*https://signrequest.com/api/v1/teams/**{{ subdomain }}**/invite_member/*",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Team"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "teams"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamsApi();\n\nvar opts = {\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.teamsList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamsApi(new GuzzleHttp\\Client(), $config);\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->teamsList($page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TeamsApi()\n\napi_response = api_instance.teams_list(\n    page=1,\n    limit=20\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamsApi();\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2007 result = apiInstance.TeamsList(page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamsApi.new\n\nopts = {\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.teams_list(opts)\n"
          }
        ]
      },
      "post": {
        "operationId": "teams_create",
        "summary": "Create a Team",
        "description": "Required fields are **name** and **subdomain** where the subdomain is globally unique.\nUse **POST** to create a Team.\nTo update a field on a Team use **PATCH**.\n\nTo use the API on behalf of a particular team change the endpoint to:\n*https://**{{ subdomain }}**.signrequest.com/api/v1/...*\n\nTo invite new team members you can use **POST**\n{\"email\":\"**email-of-member-to-invite@example.com**\",\"is_admin\":false,\"is_owner\":false} to:\n*https://signrequest.com/api/v1/teams/**{{ subdomain }}**/invite_member/*",
        "requestBody": {
          "$ref": "#/components/requestBodies/Team"
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Team"
                }
              }
            }
          }
        },
        "tags": [
          "teams"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamsApi();\n\nvar data = new SignrequestClient.Team();\ndata.name = 'Your team name';\ndata.subdomain = 'your_team';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.teamsCreate(data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamsApi(new GuzzleHttp\\Client(), $config);\n$data = new \\SignRequest\\Model\\Team();\n$data->setName('Your team name');\n$data->setSubdomain('your_team');\n\n$result = $apiInstance->teamsCreate($data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TeamsApi()\ndata = signrequest_client.Team(\n    name='Your team name',\n    subdomain='your_team'\n)\n\napi_response = api_instance.teams_create(data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamsApi();\nvar data = new Team();\ndata.Name = \"Your team name\";\ndata.Subdomain = \"your_team\";\n\nTeam result = apiInstance.TeamsCreate(data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamsApi.new\ndata = SignRequestClient::Team.new\ndata.name = 'Your team name'\ndata.subdomain = 'your_team'\n\nresult = api_instance.teams_create(data)\n"
          }
        ]
      },
      "parameters": []
    },
    "/teams/{subdomain}/": {
      "get": {
        "operationId": "teams_read",
        "summary": "Retrieve a Team",
        "description": "Required fields are **name** and **subdomain** where the subdomain is globally unique.\nUse **POST** to create a Team.\nTo update a field on a Team use **PATCH**.\n\nTo use the API on behalf of a particular team change the endpoint to:\n*https://**{{ subdomain }}**.signrequest.com/api/v1/...*\n\nTo invite new team members you can use **POST**\n{\"email\":\"**email-of-member-to-invite@example.com**\",\"is_admin\":false,\"is_owner\":false} to:\n*https://signrequest.com/api/v1/teams/**{{ subdomain }}**/invite_member/*",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Team"
                }
              }
            }
          }
        },
        "tags": [
          "teams"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamsApi();\n\nvar subdomain = \"subdomain_example\";\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.teamsRead(subdomain, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamsApi(new GuzzleHttp\\Client(), $config);\n$subdomain = \"subdomain_example\";\n\n$result = $apiInstance->teamsRead($subdomain);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TeamsApi()\nsubdomain = 'subdomain_example'\n\napi_response = api_instance.teams_read(subdomain)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamsApi();\nvar subdomain = \"subdomain_example\";\n\nTeam result = apiInstance.TeamsRead(subdomain);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamsApi.new\nsubdomain = 'subdomain_example'\n\nresult = api_instance.teams_read(subdomain)\n"
          }
        ]
      },
      "patch": {
        "operationId": "teams_partial_update",
        "summary": "Update a Team",
        "description": "Required fields are **name** and **subdomain** where the subdomain is globally unique.\nUse **POST** to create a Team.\nTo update a field on a Team use **PATCH**.\n\nTo use the API on behalf of a particular team change the endpoint to:\n*https://**{{ subdomain }}**.signrequest.com/api/v1/...*\n\nTo invite new team members you can use **POST**\n{\"email\":\"**email-of-member-to-invite@example.com**\",\"is_admin\":false,\"is_owner\":false} to:\n*https://signrequest.com/api/v1/teams/**{{ subdomain }}**/invite_member/*",
        "requestBody": {
          "$ref": "#/components/requestBodies/Team"
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Team"
                }
              }
            }
          }
        },
        "tags": [
          "teams"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamsApi();\n\nvar subdomain = \"subdomain_example\";\nvar data = new SignrequestClient.Team();\ndata.name = 'new name';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.teamsPartialUpdate(subdomain, data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamsApi(new GuzzleHttp\\Client(), $config);\n$subdomain = \"subdomain_example\";\n$data = new \\SignRequest\\Model\\Team();\n$data->setName('new name');\n\n$result = $apiInstance->teamsPartialUpdate($subdomain, $data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TeamsApi()\nsubdomain = 'subdomain_example'\ndata = signrequest_client.Team(name='new name')\n\napi_response = api_instance.teams_partial_update(subdomain, data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamsApi();\nvar subdomain = \"subdomain_example\";\nvar data = new Team();\ndata.Name = \"new name\";\n\nTeam result = apiInstance.TeamsPartialUpdate(subdomain, data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamsApi.new\nsubdomain = 'subdomain_example'\ndata = SignRequestClient::Team.new\ndata.name = 'new name'\n\nresult = api_instance.teams_update(subdomain, data)\n"
          }
        ]
      },
      "delete": {
        "operationId": "teams_delete",
        "summary": "Delete a Team",
        "description": "Required fields are **name** and **subdomain** where the subdomain is globally unique.\nUse **POST** to create a Team.\nTo update a field on a Team use **PATCH**.\n\nTo use the API on behalf of a particular team change the endpoint to:\n*https://**{{ subdomain }}**.signrequest.com/api/v1/...*\n\nTo invite new team members you can use **POST**\n{\"email\":\"**email-of-member-to-invite@example.com**\",\"is_admin\":false,\"is_owner\":false} to:\n*https://signrequest.com/api/v1/teams/**{{ subdomain }}**/invite_member/*",
        "responses": {
          "204": {
            "description": ""
          }
        },
        "tags": [
          "teams"
        ]
      },
      "parameters": [
        {
          "name": "subdomain",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string",
            "format": "slug"
          }
        }
      ]
    },
    "/teams/{subdomain}/invite_member/": {
      "post": {
        "operationId": "teams_invite_member",
        "summary": "Invite a Team Member",
        "description": "Required fields are **name** and **subdomain** where the subdomain is globally unique.\nUse **POST** to create a Team.\nTo update a field on a Team use **PATCH**.\n\nTo use the API on behalf of a particular team change the endpoint to:\n*https://**{{ subdomain }}**.signrequest.com/api/v1/...*\n\nTo invite new team members you can use **POST**\n{\"email\":\"**email-of-member-to-invite@example.com**\",\"is_admin\":false,\"is_owner\":false} to:\n*https://signrequest.com/api/v1/teams/**{{ subdomain }}**/invite_member/*",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InviteMember"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InviteMember"
                }
              }
            }
          }
        },
        "tags": [
          "teams"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TeamsApi();\n\nvar subdomain = \"subdomain_example\";\nvar data = new SignrequestClient.InviteMember();\ndata.email = 'invited_user@example.com';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\napiInstance.teamsInviteMember(subdomain, data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TeamsApi(new GuzzleHttp\\Client(), $config);\n$subdomain = \"subdomain_example\";\n$data = new \\SignRequest\\Model\\InviteMember();\n$data->setEmail('invited_user@example.com');\n\n$result = $apiInstance->teamsInviteMember($subdomain, $data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TeamsApi()\nsubdomain = 'subdomain_example'\ndata = signrequest_client.InviteMember(\n    email='invited_user@example.com'\n)\n\napi_response = api_instance.teams_invite_member(subdomain, data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TeamsApi();\nvar subdomain = \"subdomain_example\";\nvar data = new InviteMember();\ndata.Email = \"invited_user@example.com\";\n\nInviteMember result = apiInstance.TeamsInviteMember(subdomain, data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamsApi.new\nsubdomain = 'subdomain_example'\ndata = SignRequestClient::InviteMember.new\ndata.email = 'invited_user@example.com'\n\nresult = api_instance.teams_invite_member(subdomain, data)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "subdomain",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string",
            "format": "slug"
          }
        }
      ]
    },
    "/templates/": {
      "get": {
        "operationId": "templates_list",
        "summary": "Retrieve a list of Templates",
        "description": "",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/Template"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "templates"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TemplatesApi();\n\nvar opts = {\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.templatesList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TemplatesApi(new GuzzleHttp\\Client(), $config);\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->templatesList($page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TemplatesApi()\npage = 1\nlimit = 20\n\napi_response = api_instance.templates_list(\n    page=page,\n    limit=limit\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TemplatesApi();\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2008 result = apiInstance.TemplatesList(page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TeamMembersApi.new\n\nopts = {\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.team_members_list(opts)\n"
          }
        ]
      },
      "parameters": []
    },
    "/templates/{uuid}/": {
      "get": {
        "operationId": "templates_read",
        "summary": "Retrieve a Template",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Template"
                }
              }
            }
          }
        },
        "tags": [
          "templates"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.TemplatesApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.templatesRead(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\TemplatesApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->templatesRead($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.TemplatesApi()\nuuid = 'uuid_example'\n\napi_response = api_instance.templates_read(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new TemplatesApi();\nvar uuid = \"uuid_example\";\n\nTemplate result = apiInstance.TemplatesRead(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::TemplatesApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.templates_read(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/webhooks/": {
      "get": {
        "operationId": "webhooks_list",
        "summary": "Retrieve a list of Webhooks",
        "description": "",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "A page number within the paginated result set.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of results to return per page.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "count",
                    "results"
                  ],
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "integer"
                    },
                    "next": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "previous": {
                      "type": "string",
                      "format": "uri",
                      "nullable": true
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/WebhookSubscription"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "webhooks"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.WebhooksApi();\n\nvar opts = {\n  'page': 1,\n  'limit': 20\n};\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.webhooksList(opts, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\WebhooksApi(new GuzzleHttp\\Client(), $config);\n$page = 1;\n$limit = 20;\n\n$result = $apiInstance->webhooksList($page, $limit);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.WebhooksApi()\n\napi_response = api_instance.webhooks_list(\n    page=1,\n    limit=20\n)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new WebhooksApi();\nvar page = 1;\nvar limit = 20;\n\nInlineResponse2009 result = apiInstance.WebhooksList(page, limit);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::WebhooksApi.new\n\nopts = {\n  page: 1,\n  limit: 20\n}\n\nresult = api_instance.webhooks_list(opts)\n"
          }
        ]
      },
      "post": {
        "operationId": "webhooks_create",
        "summary": "Create a Webhook",
        "description": "",
        "requestBody": {
          "$ref": "#/components/requestBodies/WebhookSubscription"
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookSubscription"
                }
              }
            }
          }
        },
        "tags": [
          "webhooks"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.WebhooksApi();\n\nvar data = new SignrequestClient.WebhookSubscription();\ndata.event_type = 'signer_signed';\ndata.callback_url = 'https://example.com/events/';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.webhooksCreate(data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\WebhooksApi(new GuzzleHttp\\Client(), $config);\n$data = new \\SignRequest\\Model\\WebhookSubscription();\n$data->setEventType('signer_signed');\n$data->setCallbackUrl('https://example.com/events/');\n\n$result = $apiInstance->webhooksCreate($data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.WebhooksApi()\ndata = signrequest_client.WebhookSubscription(\n    event_type='signer_signed',\n    callback_url='https://example.com/events/'\n)\n\napi_response = api_instance.webhooks_create(data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new WebhooksApi();\nvar data = new WebhookSubscription();\ndata.EventType = WebhookSubscription.EventTypeEnum.Signersigned;\ndata.CallbackUrl = \"https://example.com/events/\";\n\nWebhookSubscription result = apiInstance.WebhooksCreate(data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::WebhooksApi.new\ndata = SignRequestClient::WebhookSubscription.new\ndata.event_type = 'signer_signed'\ndata.callback_url = 'https://example.com/events/'\n\nresult = api_instance.webhooks_create(data)\n"
          }
        ]
      },
      "parameters": []
    },
    "/webhooks/{uuid}/": {
      "get": {
        "operationId": "webhooks_read",
        "summary": "Retrieve a Webhook",
        "description": "",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookSubscription"
                }
              }
            }
          }
        },
        "tags": [
          "webhooks"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.WebhooksApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.webhooksRead(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\WebhooksApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$result = $apiInstance->webhooksRead($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.WebhooksApi()\nuuid = 'uuid_example'\n\napi_response = api_instance.webhooks_read(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new WebhooksApi();\nvar uuid = \"uuid_example\";\n\nWebhookSubscription result = apiInstance.WebhooksRead(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::WebhooksApi.new\nuuid = 'uuid_example'\n\nresult = api_instance.webhooks_read(uuid)\n"
          }
        ]
      },
      "put": {
        "operationId": "webhooks_update",
        "summary": "Update a Webhook",
        "description": "",
        "requestBody": {
          "$ref": "#/components/requestBodies/WebhookSubscription"
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookSubscription"
                }
              }
            }
          }
        },
        "tags": [
          "webhooks"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.WebhooksApi();\n\nvar uuid = 'uuid_example';\n\nvar data = new SignrequestClient.WebhookSubscription();\ndata.event_type = 'signer_email_bounced';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.webhooksUpdate(uuid, data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\WebhooksApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n$data = new \\SignRequest\\Model\\WebhookSubscription();\n$data->setEventType('signer_email_bounced');\n\n$result = $apiInstance->webhooksUpdate($uuid, $data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.WebhooksApi()\nuuid = 'uuid_example'\ndata = signrequest_client.WebhookSubscription(\n    event_type='signer_email_bounced'\n)\n\napi_response = api_instance.webhooks_update(uuid, data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new WebhooksApi();\nvar uuid = \"uuid_example\";\nvar data = new WebhookSubscription();\ndata.EventType = WebhookSubscription.EventTypeEnum.Signeremailbounced;\n\nWebhookSubscription result = apiInstance.WebhooksUpdate(uuid, data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::WebhooksApi.new\nuuid = 'uuid_example'\ndata = SignRequestClient::WebhookSubscription.new\ndata.event_type = 'signer_email_bounced'\n\nresult = api_instance.webhooks_update(uuid, data)\n"
          }
        ]
      },
      "patch": {
        "operationId": "webhooks_partial_update",
        "summary": "Partially update a Webhook",
        "description": "",
        "requestBody": {
          "$ref": "#/components/requestBodies/WebhookSubscription"
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookSubscription"
                }
              }
            }
          }
        },
        "tags": [
          "webhooks"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.WebhooksApi();\n\nvar uuid = 'uuid_example';\n\nvar data = new SignrequestClient.WebhookSubscription();\ndata.event_type = 'signer_email_bounced';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully. Returned data: ' + data);\n  }\n};\n\napiInstance.webhooksPartialUpdate(uuid, data, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\WebhooksApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n$data = new \\SignRequest\\Model\\WebhookSubscription();\n$data->setEventType('signer_email_bounced');\n\n$result = $apiInstance->webhooksPartialUpdate($uuid, $data);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.WebhooksApi()\nuuid = 'uuid_example'\ndata = signrequest_client.WebhookSubscription(\n    event_type='signer_email_bounced'\n)\n\napi_response = api_instance.webhooks_partial_update(uuid, data)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new WebhooksApi();\nvar uuid = \"uuid_example\";\nvar data = new WebhookSubscription();\ndata.EventType = WebhookSubscription.EventTypeEnum.Signeremailbounced;\n\nWebhookSubscription result = apiInstance.WebhooksPartialUpdate(uuid, data);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::WebhooksApi.new\nuuid = 'uuid_example'\ndata = SignRequestClient::WebhookSubscription.new\ndata.event_type = 'signer_email_bounced'\n\nresult = api_instance.webhooks_partial_update(uuid, data)\n"
          }
        ]
      },
      "delete": {
        "operationId": "webhooks_delete",
        "summary": "Delete a Webhook",
        "description": "",
        "responses": {
          "204": {
            "description": ""
          }
        },
        "tags": [
          "webhooks"
        ],
        "x-code-samples": [
          {
            "lang": "javascript",
            "source": "var SignrequestClient = require('signrequest-client');\nvar apiInstance = new SignrequestClient.WebhooksApi();\n\nvar uuid = 'uuid_example';\n\nvar callback = function(error, data, response) {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log('API called successfully.');\n  }\n};\n\napiInstance.webhooksDelete(uuid, callback);\n"
          },
          {
            "lang": "php",
            "source": "<?php\n\n$config = SignRequest\\Configuration::getDefaultConfiguration();\n\n$apiInstance = new SignRequest\\Api\\WebhooksApi(new GuzzleHttp\\Client(), $config);\n$uuid = \"uuid_example\";\n\n$apiInstance->webhooksDelete($uuid);\n\n?>\n"
          },
          {
            "lang": "python",
            "source": "import signrequest_client\n\napi_instance = signrequest_client.WebhooksApi()\nuuid = 'uuid_example'\n\napi_instance.webhooks_delete(uuid)\n"
          },
          {
            "lang": "c#",
            "source": "var apiInstance = new WebhooksApi();\nvar uuid = \"uuid_example\";\n\napiInstance.WebhooksDelete(uuid);\n"
          },
          {
            "lang": "ruby",
            "source": "api_instance = SignRequestClient::WebhooksApi.new\nuuid = 'uuid_example'\n\napi_instance.webhooks_delete(uuid)\n"
          }
        ]
      },
      "parameters": [
        {
          "name": "uuid",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ]
    }
  },
  "tags": [
    {
      "name": "api-tokens",
      "description": "You can create an API token in the [team api settings page](/#/teams). \n"
    },
    {
      "name": "audit-events",
      "description": ""
    },
    {
      "name": "document-attachments",
      "description": ""
    },
    {
      "name": "documents",
      "description": ""
    },
    {
      "name": "documents-search",
      "description": ""
    },
    {
      "name": "events",
      "description": ""
    },
    {
      "name": "signrequest-quick-create",
      "description": "Use this endpoint when you need to create a document and send the SignRequest in one API call. This endpoint takes all of the fields of the [documents](#operation/documents_createt) and [signrequests](#operation/signrequests_create) endpoints together, creates the document, and sends the SignRequest.\n\nOptionally this endpoint also accepts the `multipart/form-data` content type if the `file` is POSTed directly. When POSTing `multipart/form-data` do not forget to also add a `Accept: 'application/json'` header. In order to deal with the nested signers data the fields can be referenced by including the index of the signer, e.g. `signer[0]email=some@email.com`. If convenient it is also possible to provide the **configuration data as json** in a field which needs to be called `data`.\n"
    },
    {
      "name": "signrequests",
      "description": ""
    },
    {
      "name": "team-members",
      "description": ""
    },
    {
      "name": "teams",
      "description": "If your application requires to create Teams and act on behalf of them you need to become an [integration partner](#section/Integration-Partners/Becoming-an-integration-partner).\n"
    },
    {
      "name": "templates",
      "description": ""
    },
    {
      "name": "webhooks",
      "description": ""
    }
  ],
  "servers": [
    {
      "url": "https://signrequest.com/api/v1"
    }
  ],
  "components": {
    "requestBodies": {
      "Team": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Team"
            }
          }
        },
        "required": true
      },
      "WebhookSubscription": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/WebhookSubscription"
            }
          }
        },
        "required": true
      }
    },
    "securitySchemes": {
      "Token": {
        "in": "header",
        "type": "apiKey",
        "name": "Authorization"
      }
    },
    "schemas": {
      "AuthToken": {
        "required": [
          "subdomain"
        ],
        "type": "object",
        "properties": {
          "email": {
            "title": "Email",
            "type": "string",
            "format": "email"
          },
          "password": {
            "title": "Password",
            "type": "string"
          },
          "subdomain": {
            "title": "Subdomain",
            "type": "string",
            "format": "slug",
            "pattern": "^[-a-zA-Z0-9_]+$",
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "type": "string",
            "minLength": 1
          },
          "key": {
            "title": "Key",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          }
        }
      },
      "AuditEvent": {
        "type": "object",
        "properties": {
          "domain": {
            "title": "Domain",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "user_uuid": {
            "title": "User uuid",
            "type": "string",
            "format": "uuid",
            "readOnly": true
          },
          "user_email": {
            "title": "User email",
            "type": "string",
            "format": "email",
            "readOnly": true,
            "minLength": 1
          },
          "user_ip": {
            "title": "User ip",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "event_type": {
            "title": "Event type",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "status": {
            "title": "Status",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "timestamp": {
            "title": "Timestamp",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          }
        }
      },
      "DocumentAttachment": {
        "required": [
          "document"
        ],
        "type": "object",
        "properties": {
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "description": "Defaults to filename, including extension",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "file": {
            "title": "File",
            "description": "Temporary URL to document attachment, expires in five minutes",
            "type": "string",
            "readOnly": true,
            "format": "uri",
            "nullable": true
          },
          "file_from_content": {
            "title": "File from content",
            "description": "Base64 encoded document content",
            "type": "string",
            "nullable": true
          },
          "file_from_content_name": {
            "title": "File from content name",
            "description": "Filename, including extension. Required when using `file_from_content`.",
            "type": "string",
            "nullable": true
          },
          "file_from_url": {
            "title": "File from url",
            "description": "Publicly accessible URL of document to be downloaded by SignRequest",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "document": {
            "title": "Document",
            "type": "string",
            "format": "uri"
          }
        }
      },
      "ExtraDocument": {
        "type": "object",
        "properties": {
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "status": {
            "title": "Status",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "status_display": {
            "title": "Status display",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          }
        }
      },
      "DocumentSearchDirect": {
        "type": "object",
        "properties": {
          "from_email": {
            "title": "From email",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "who": {
            "title": "Who",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "status": {
            "title": "Status",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "created": {
            "title": "Created",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "autocomplete": {
            "title": "Autocomplete",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "nr_extra_docs": {
            "title": "Nr extra docs",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "extra_docs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtraDocument"
            },
            "readOnly": true
          },
          "signer_emails": {
            "type": "array",
            "items": {
              "type": "string",
              "nullable": true
            },
            "readOnly": true
          },
          "status_display": {
            "title": "Status display",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "created_timestamp": {
            "title": "Created timestamp",
            "type": "integer",
            "readOnly": true
          },
          "finished_on_timestamp": {
            "title": "Finished on timestamp",
            "type": "integer",
            "readOnly": true
          },
          "parent_doc": {
            "title": "Parent doc",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "finished_on": {
            "title": "Finished on",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "subdomain": {
            "title": "Subdomain",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "processing": {
            "title": "Processing",
            "type": "boolean",
            "readOnly": true
          }
        }
      },
      "InlineTeam": {
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "subdomain": {
            "title": "Subdomain",
            "type": "string",
            "format": "slug",
            "pattern": "^[-a-zA-Z0-9_]+$",
            "readOnly": true,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          }
        },
        "readOnly": true
      },
      "User": {
        "required": [
          "email"
        ],
        "type": "object",
        "properties": {
          "email": {
            "title": "Email address",
            "type": "string",
            "format": "email",
            "maxLength": 254,
            "minLength": 1
          },
          "first_name": {
            "title": "First name",
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "title": "Last name",
            "type": "string",
            "maxLength": 255
          },
          "display_name": {
            "title": "Display name",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          }
        }
      },
      "InlinePrefillTags": {
        "description": "Prefill signer input data, see [prefill tags](#section/Preparing-a-document/Prefill-tags-templates)",
        "type": "object",
        "properties": {
          "external_id": {
            "title": "External id",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "text": {
            "title": "Text",
            "type": "string",
            "nullable": true
          },
          "checkbox_value": {
            "title": "Checkbox value",
            "type": "boolean",
            "nullable": true
          },
          "date_value": {
            "title": "Date value",
            "type": "string",
            "format": "date",
            "nullable": true
          }
        }
      },
      "InlineIntegrationData": {
        "type": "object",
        "properties": {
          "integration": {
            "title": "Integration",
            "type": "string",
            "enum": [
              "mfiles",
              "salesforce",
              "formdesk",
              "zapier",
              "microsoft-flow"
            ],
            "nullable": true
          },
          "integration_data": {
            "title": "Integration data",
            "type": "object"
          }
        }
      },
      "FileFromSf": {
        "required": [
          "object_type",
          "object_id"
        ],
        "type": "object",
        "properties": {
          "object_type": {
            "title": "Object type",
            "type": "string",
            "minLength": 1
          },
          "object_id": {
            "title": "Object id",
            "type": "string",
            "minLength": 1
          },
          "uid": {
            "title": "Uid",
            "type": "string",
            "minLength": 1
          }
        },
        "nullable": true
      },
      "RequiredAttachment": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "type": "string",
            "maxLength": 255,
            "minLength": 1
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          }
        }
      },
      "SignerInputs": {
        "required": [
          "page_index"
        ],
        "type": "object",
        "properties": {
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "s",
              "i",
              "n",
              "d",
              "t",
              "c"
            ],
            "nullable": true
          },
          "page_index": {
            "title": "Page index",
            "type": "integer"
          },
          "text": {
            "title": "Text",
            "type": "string"
          },
          "checkbox_value": {
            "title": "Checkbox value",
            "type": "boolean",
            "nullable": true
          },
          "date_value": {
            "title": "Date value",
            "type": "string",
            "format": "date",
            "nullable": true
          },
          "external_id": {
            "title": "External id",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "placeholder_uuid": {
            "title": "Placeholder uuid",
            "type": "string",
            "maxLength": 36,
            "nullable": true
          }
        }
      },
      "SignerAttachment": {
        "type": "object",
        "properties": {
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "description": "Defaults to filename",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "file": {
            "title": "File",
            "type": "string",
            "readOnly": true,
            "format": "uri",
            "nullable": true
          },
          "for_attachment": {
            "$ref": "#/components/schemas/RequiredAttachment"
          }
        }
      },
      "InlineDocumentSignerIntegrationData": {
        "type": "object",
        "properties": {
          "integration": {
            "title": "Integration",
            "type": "string",
            "enum": [
              "mfiles",
              "salesforce",
              "formdesk",
              "zapier",
              "microsoft-flow"
            ],
            "nullable": true
          },
          "integration_data": {
            "title": "Integration data",
            "type": "object"
          }
        }
      },
      "Signer": {
        "required": [
          "email"
        ],
        "type": "object",
        "properties": {
          "email": {
            "title": "Email",
            "type": "string",
            "format": "email",
            "maxLength": 255,
            "minLength": 1
          },
          "display_name": {
            "title": "Display name",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "first_name": {
            "title": "First name",
            "type": "string",
            "maxLength": 255
          },
          "last_name": {
            "title": "Last name",
            "type": "string",
            "maxLength": 255
          },
          "email_viewed": {
            "title": "Email viewed",
            "type": "boolean",
            "readOnly": true
          },
          "viewed": {
            "title": "Viewed",
            "type": "boolean",
            "readOnly": true
          },
          "signed": {
            "title": "Signed",
            "type": "boolean",
            "readOnly": true
          },
          "downloaded": {
            "title": "Downloaded",
            "type": "boolean",
            "readOnly": true
          },
          "signed_on": {
            "title": "Signed on",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "needs_to_sign": {
            "title": "Needs to sign",
            "description": "When `false` user does not need to sign, but will receive a copy of the signed document and signing log, see: [Copy only](#section/Additional-signing-methods/Copy-only)",
            "type": "boolean",
            "default": true
          },
          "approve_only": {
            "title": "Approve only",
            "description": "Require user to approve the document (without adding a signature), see: [Approve only](#section/Additional-signing-methods/Approve-only)",
            "type": "boolean"
          },
          "notify_only": {
            "title": "Notify only",
            "description": "Send notifications about the document and a copy of the signed document and signing log, but don't require them to take any action, see: [Notify only](#section/Additional-signing-methods/Notify-only)",
            "type": "boolean"
          },
          "in_person": {
            "title": "In person",
            "description": "When used in combination with an embed url on the sender, after sender has signed, they will be redirected to the next `in_person` signer, see: [In person signing](#section/Additional-signing-methods/In-person-signing)",
            "type": "boolean"
          },
          "order": {
            "title": "Order",
            "type": "integer",
            "maximum": 2147483647,
            "minimum": 0
          },
          "language": {
            "title": "Language",
            "type": "string",
            "enum": [
              "en",
              "en-gb",
              "nl",
              "fr",
              "de",
              "he",
              "da",
              "fi",
              "hu",
              "it",
              "no",
              "pl",
              "pt",
              "es",
              "sv",
              "ru",
              "ja"
            ],
            "nullable": true
          },
          "force_language": {
            "title": "Force language",
            "type": "boolean"
          },
          "emailed": {
            "title": "Emailed",
            "type": "boolean",
            "readOnly": true
          },
          "verify_phone_number": {
            "title": "Verify phone number",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "verify_bank_account": {
            "title": "Verify bank account",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "declined": {
            "title": "Declined",
            "type": "boolean",
            "readOnly": true
          },
          "declined_on": {
            "title": "Declined on",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "forwarded": {
            "title": "Forwarded",
            "type": "boolean",
            "readOnly": true
          },
          "forwarded_on": {
            "title": "Forwarded on",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "forwarded_to_email": {
            "title": "Forwarded to email",
            "type": "string",
            "format": "email",
            "readOnly": true,
            "minLength": 1
          },
          "forwarded_reason": {
            "title": "Forwarded reason",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "message": {
            "title": "Message",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "embed_url_user_id": {
            "title": "Embed url user id",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "inputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SignerInputs"
            },
            "readOnly": true
          },
          "use_stamp_for_approve_only": {
            "title": "Use stamp for approve only",
            "description": "Place an approval stamp on a document when a signer approves a document",
            "type": "boolean",
            "nullable": true
          },
          "embed_url": {
            "title": "Embed url",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SignerAttachment"
            },
            "readOnly": true
          },
          "redirect_url": {
            "title": "Redirect url",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "redirect_url_declined": {
            "title": "Redirect url declined",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "after_document": {
            "title": "After document",
            "type": "string",
            "format": "uri"
          },
          "integrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlineDocumentSignerIntegrationData"
            }
          },
          "password": {
            "title": "Password",
            "description": "Require the signer to enter this password before signing a document. This field is write only.",
            "type": "string",
            "minLength": 1
          }
        }
      },
      "InlineSignRequest": {
        "type": "object",
        "properties": {
          "from_email": {
            "title": "From email",
            "description": "Email of user sending the SignRequest (must be a validated email)",
            "type": "string",
            "format": "email",
            "readOnly": true
          },
          "from_email_name": {
            "title": "From email name",
            "description": "Name to be used in the `From` email header, e.g. `{from_email_name} <no-reply@signrequest.com>`",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "is_being_prepared": {
            "title": "Is being prepared",
            "description": "Have the sender of a SignRequest prepare the document before sending the request out, see: [prepare using the web interface](#section/Preparing-a-document/Prepare-using-the-web-interface)",
            "type": "boolean",
            "readOnly": true
          },
          "prepare_url": {
            "title": "Prepare url",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "redirect_url": {
            "title": "Redirect url",
            "description": "URL at which SignRequest will redirect to when a document is signed",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "redirect_url_declined": {
            "title": "Redirect url declined",
            "description": "URL at which SignRequest will redirect to when a document is declined",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "required_attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RequiredAttachment"
            },
            "readOnly": true
          },
          "disable_attachments": {
            "title": "Disable attachments",
            "description": "Disable uploading/adding of attachments",
            "type": "boolean",
            "readOnly": true
          },
          "disable_text_signatures": {
            "title": "Disable text signatures",
            "description": "Disable usage of signatures generated by typing (text)",
            "type": "boolean",
            "readOnly": true
          },
          "disable_text": {
            "title": "Disable text",
            "description": "Disable adding of text",
            "type": "boolean",
            "readOnly": true
          },
          "disable_date": {
            "title": "Disable date",
            "description": "Disable adding of dates",
            "type": "boolean",
            "readOnly": true
          },
          "disable_emails": {
            "title": "Disable emails",
            "description": "Disable all SignRequest status emails as well as the email that contains the signed documents",
            "type": "boolean",
            "readOnly": true
          },
          "disable_upload_signatures": {
            "title": "Disable upload signatures",
            "description": "Disable usage of uploaded signatures (images)",
            "type": "boolean",
            "readOnly": true
          },
          "force_signature_color": {
            "title": "Force signature color",
            "description": "Force specific color for the signature",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "disable_blockchain_proof": {
            "title": "Disable blockchain proof",
            "description": "Disables storing timestamp proof hashes in blockchain integrations.",
            "type": "boolean",
            "readOnly": true
          },
          "text_message_verification_locked": {
            "title": "Text message verification locked",
            "description": "When true a text message verification is needed before the signer can see the document",
            "type": "boolean",
            "readOnly": true
          },
          "subject": {
            "title": "Subject",
            "description": "Subject of SignRequest email",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "message": {
            "title": "Message",
            "description": "Message to include in SignRequest email, may contain the following html tags: `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "who": {
            "title": "Who",
            "description": "`m`: only me, `mo`: me and others, `o`: only others",
            "type": "string",
            "enum": [
              "m",
              "mo",
              "o"
            ],
            "readOnly": true
          },
          "send_reminders": {
            "title": "Send reminders",
            "description": "Automatically remind signers to sign a document, see: [automatic reminders](#section/Working-with-a-SignRequest/Automatic-reminders)",
            "type": "boolean",
            "readOnly": true
          },
          "signers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Signer"
            },
            "readOnly": true
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          }
        },
        "readOnly": true
      },
      "SigningLog": {
        "type": "object",
        "properties": {
          "pdf": {
            "title": "Pdf",
            "description": "Temporary URL to signing log, expires in five minutes",
            "type": "string",
            "readOnly": true,
            "format": "uri",
            "nullable": true
          },
          "security_hash": {
            "title": "Security hash",
            "description": "SHA256 hash of PDF contents",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          }
        },
        "readOnly": true
      },
      "Document": {
        "type": "object",
        "properties": {
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "team": {
            "type": "object",
            "properties": {
              "name": {
                "title": "Name",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "subdomain": {
                "title": "Subdomain",
                "type": "string",
                "format": "slug",
                "pattern": "^[-a-zA-Z0-9_]+$",
                "readOnly": true,
                "minLength": 1
              },
              "url": {
                "title": "Url",
                "type": "string",
                "format": "uri",
                "readOnly": true
              }
            },
            "readOnly": true
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "file_as_pdf": {
            "title": "File as pdf",
            "description": "Temporary URL to original file as PDF, expires in five minutes",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "description": "Defaults to filename, including extension",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "external_id": {
            "title": "External id",
            "description": "ID used to reference document in external system",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "frontend_id": {
            "title": "Frontend id",
            "description": "Shared secret used in conjunction with <a href=\"#section/Frontend-API/SignRequest-js-client-(beta)\">SignRequest-js client</a> to grant user access to a document that's not a member of the document's team",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "file": {
            "title": "File",
            "description": "Temporary URL to original file, expires in five minutes",
            "type": "string",
            "readOnly": true,
            "format": "uri",
            "nullable": true
          },
          "file_from_url": {
            "title": "File from url",
            "description": "Publicly accessible URL of document to be downloaded by SignRequest",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "events_callback_url": {
            "title": "Events callback url",
            "description": "URL at which to receive [event callbacks](#section/Events/Events-callback) for this document",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "file_from_content": {
            "title": "File from content",
            "description": "Base64 encoded document content",
            "type": "string",
            "nullable": true
          },
          "file_from_content_name": {
            "title": "File from content name",
            "description": "Filename, including extension. Required when using `file_from_content`.",
            "type": "string",
            "nullable": true
          },
          "template": {
            "title": "Template",
            "type": "string",
            "format": "uri",
            "nullable": true
          },
          "prefill_tags": {
            "description": "Prefill signer input data, see [prefill tags](#section/Preparing-a-document/Prefill-tags-templates)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlinePrefillTags"
            }
          },
          "integrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlineIntegrationData"
            }
          },
          "file_from_sf": {
            "$ref": "#/components/schemas/FileFromSf"
          },
          "auto_delete_days": {
            "title": "Auto delete days",
            "description": "Number of days after which a finished document (signed/cancelled/declined) will be automatically deleted",
            "type": "integer",
            "maximum": 730,
            "minimum": 1,
            "nullable": true
          },
          "auto_expire_days": {
            "title": "Auto expire days",
            "description": "Number of days after which a non finished document will be automatically expired",
            "type": "integer",
            "maximum": 730,
            "minimum": 1,
            "nullable": true
          },
          "pdf": {
            "title": "Pdf",
            "description": "Temporary URL to signed document as PDF, expires in five minutes",
            "type": "string",
            "readOnly": true,
            "format": "uri"
          },
          "status": {
            "title": "Status",
            "description": "`co`: converting, `ne`: new, `se`: sent, `vi`: viewed, `si`: signed, `do`: downloaded, `sd`: signed and downloaded, `ca`: cancelled, `de`: declined, `ec`: error converting, `es`: error sending, `xp`: expired",
            "type": "string",
            "enum": [
              "co",
              "ne",
              "se",
              "vi",
              "si",
              "do",
              "sd",
              "ca",
              "de",
              "ec",
              "es",
              "xp"
            ],
            "readOnly": true
          },
          "signrequest": {
            "type": "object",
            "properties": {
              "from_email": {
                "title": "From email",
                "description": "Email of user sending the SignRequest (must be a validated email)",
                "type": "string",
                "format": "email",
                "readOnly": true
              },
              "from_email_name": {
                "title": "From email name",
                "description": "Name to be used in the `From` email header, e.g. `{from_email_name} <no-reply@signrequest.com>`",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "is_being_prepared": {
                "title": "Is being prepared",
                "description": "Have the sender of a SignRequest prepare the document before sending the request out, see: [prepare using the web interface](#section/Preparing-a-document/Prepare-using-the-web-interface)",
                "type": "boolean",
                "readOnly": true
              },
              "prepare_url": {
                "title": "Prepare url",
                "type": "string",
                "format": "uri",
                "readOnly": true,
                "minLength": 1
              },
              "redirect_url": {
                "title": "Redirect url",
                "description": "URL at which SignRequest will redirect to when a document is signed",
                "type": "string",
                "format": "uri",
                "readOnly": true,
                "minLength": 1
              },
              "redirect_url_declined": {
                "title": "Redirect url declined",
                "description": "URL at which SignRequest will redirect to when a document is declined",
                "type": "string",
                "format": "uri",
                "readOnly": true,
                "minLength": 1
              },
              "required_attachments": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RequiredAttachment"
                },
                "readOnly": true
              },
              "disable_attachments": {
                "title": "Disable attachments",
                "description": "Disable uploading/adding of attachments",
                "type": "boolean",
                "readOnly": true
              },
              "disable_text_signatures": {
                "title": "Disable text signatures",
                "description": "Disable usage of signatures generated by typing (text)",
                "type": "boolean",
                "readOnly": true
              },
              "disable_text": {
                "title": "Disable text",
                "description": "Disable adding of text",
                "type": "boolean",
                "readOnly": true
              },
              "disable_date": {
                "title": "Disable date",
                "description": "Disable adding of dates",
                "type": "boolean",
                "readOnly": true
              },
              "disable_emails": {
                "title": "Disable emails",
                "description": "Disable all SignRequest status emails as well as the email that contains the signed documents",
                "type": "boolean",
                "readOnly": true
              },
              "disable_upload_signatures": {
                "title": "Disable upload signatures",
                "description": "Disable usage of uploaded signatures (images)",
                "type": "boolean",
                "readOnly": true
              },
              "force_signature_color": {
                "title": "Force signature color",
                "description": "Force specific color for the signature",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "disable_blockchain_proof": {
                "title": "Disable blockchain proof",
                "description": "Disables storing timestamp proof hashes in blockchain integrations.",
                "type": "boolean",
                "readOnly": true
              },
              "text_message_verification_locked": {
                "title": "Text message verification locked",
                "description": "When true a text message verification is needed before the signer can see the document",
                "type": "boolean",
                "readOnly": true
              },
              "subject": {
                "title": "Subject",
                "description": "Subject of SignRequest email",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "message": {
                "title": "Message",
                "description": "Message to include in SignRequest email, may contain the following html tags: `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "who": {
                "title": "Who",
                "description": "`m`: only me, `mo`: me and others, `o`: only others",
                "type": "string",
                "enum": [
                  "m",
                  "mo",
                  "o"
                ],
                "readOnly": true
              },
              "send_reminders": {
                "title": "Send reminders",
                "description": "Automatically remind signers to sign a document, see: [automatic reminders](#section/Working-with-a-SignRequest/Automatic-reminders)",
                "type": "boolean",
                "readOnly": true
              },
              "signers": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Signer"
                },
                "readOnly": true
              },
              "uuid": {
                "title": "Uuid",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              }
            },
            "readOnly": true
          },
          "api_used": {
            "title": "Api used",
            "description": "Indicates whether document was created using the API",
            "type": "boolean",
            "readOnly": true
          },
          "signing_log": {
            "type": "object",
            "properties": {
              "pdf": {
                "title": "Pdf",
                "description": "Temporary URL to signing log, expires in five minutes",
                "type": "string",
                "readOnly": true,
                "format": "uri",
                "nullable": true
              },
              "security_hash": {
                "title": "Security hash",
                "description": "SHA256 hash of PDF contents",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              }
            },
            "readOnly": true
          },
          "security_hash": {
            "title": "Security hash",
            "description": "SHA256 hash of PDF contents",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentAttachment"
            },
            "readOnly": true
          },
          "auto_delete_after": {
            "title": "Auto delete after",
            "description": "Date and time calculated using `auto_delete_days` after which a finished document (signed/cancelled/declined) will be automatically deleted",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "sandbox": {
            "title": "Sandbox",
            "description": "Indicates whether document was created as part of a sandbox team",
            "type": "boolean",
            "readOnly": true
          },
          "auto_expire_after": {
            "title": "Auto expire after",
            "description": "Date and time calculated using `auto_expire_days` after which a non finished document will be automatically expired",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "processing": {
            "title": "Processing",
            "description": "Indicates whether a change to the document is processing and the PDF may be out of date. It is recommended to wait until processing has finished before downloading the PDF. Webhooks are not sent until processing has been completed.",
            "type": "boolean",
            "readOnly": true
          }
        }
      },
      "Event": {
        "type": "object",
        "properties": {
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "status": {
            "title": "Status",
            "type": "string",
            "enum": [
              "ok",
              "error"
            ],
            "readOnly": true
          },
          "event_type": {
            "title": "Event type",
            "type": "string",
            "enum": [
              "convert_error",
              "converted",
              "sending_error",
              "sent",
              "declined",
              "cancelled",
              "expired",
              "signed",
              "viewed",
              "downloaded",
              "signer_signed",
              "signer_email_bounced",
              "signer_viewed_email",
              "signer_viewed",
              "signer_forwarded",
              "signer_downloaded",
              "signrequest_received"
            ],
            "readOnly": true
          },
          "delivered": {
            "title": "Delivered",
            "type": "boolean",
            "readOnly": true
          },
          "delivered_on": {
            "title": "Delivered on",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "callback_status_code": {
            "title": "Callback status code",
            "type": "integer",
            "readOnly": true
          },
          "timestamp": {
            "title": "Timestamp",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "team": {
            "type": "object",
            "properties": {
              "name": {
                "title": "Name",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "subdomain": {
                "title": "Subdomain",
                "type": "string",
                "format": "slug",
                "pattern": "^[-a-zA-Z0-9_]+$",
                "readOnly": true,
                "minLength": 1
              },
              "url": {
                "title": "Url",
                "type": "string",
                "format": "uri",
                "readOnly": true
              }
            },
            "readOnly": true
          },
          "document": {
            "$ref": "#/components/schemas/Document"
          },
          "signer": {
            "$ref": "#/components/schemas/Signer"
          }
        }
      },
      "SignRequestQuickCreate": {
        "required": [
          "signers"
        ],
        "type": "object",
        "properties": {
          "from_email": {
            "title": "From email",
            "description": "Email of user sending the SignRequest (must be a validated email)",
            "type": "string",
            "format": "email",
            "maxLength": 255,
            "minLength": 1
          },
          "from_email_name": {
            "title": "From email name",
            "description": "Name to be used in the `From` email header, e.g. `{from_email_name} <no-reply@signrequest.com>`",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "is_being_prepared": {
            "title": "Is being prepared",
            "description": "Have the sender of a SignRequest prepare the document before sending the request out, see: [prepare using the web interface](#section/Preparing-a-document/Prepare-using-the-web-interface)",
            "type": "boolean",
            "nullable": true
          },
          "prepare_url": {
            "title": "Prepare url",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "redirect_url": {
            "title": "Redirect url",
            "description": "URL at which SignRequest will redirect to when a document is signed",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "redirect_url_declined": {
            "title": "Redirect url declined",
            "description": "URL at which SignRequest will redirect to when a document is declined",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "required_attachments": {
            "description": "Attachments that signers are required to upload",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RequiredAttachment"
            }
          },
          "disable_attachments": {
            "title": "Disable attachments",
            "description": "Disable uploading/adding of attachments",
            "type": "boolean"
          },
          "disable_text_signatures": {
            "title": "Disable text signatures",
            "description": "Disable usage of signatures generated by typing (text)",
            "type": "boolean"
          },
          "disable_text": {
            "title": "Disable text",
            "description": "Disable adding of text",
            "type": "boolean"
          },
          "disable_date": {
            "title": "Disable date",
            "description": "Disable adding of dates",
            "type": "boolean"
          },
          "disable_emails": {
            "title": "Disable emails",
            "description": "Disable all SignRequest status emails as well as the email that contains the signed documents",
            "type": "boolean"
          },
          "disable_upload_signatures": {
            "title": "Disable upload signatures",
            "description": "Disable usage of uploaded signatures (images)",
            "type": "boolean"
          },
          "force_signature_color": {
            "title": "Force signature color",
            "description": "Force specific color for the signature",
            "type": "string",
            "maxLength": 100,
            "nullable": true
          },
          "disable_blockchain_proof": {
            "title": "Disable blockchain proof",
            "description": "Disables storing timestamp proof hashes in blockchain integrations.",
            "type": "boolean",
            "nullable": true
          },
          "text_message_verification_locked": {
            "title": "Text message verification locked",
            "description": "When true a text message verification is needed before the signer can see the document",
            "type": "boolean",
            "nullable": true
          },
          "subject": {
            "title": "Subject",
            "description": "Subject of SignRequest email",
            "type": "string",
            "maxLength": 512,
            "nullable": true
          },
          "message": {
            "title": "Message",
            "description": "Message to include in SignRequest email, may contain the following html tags: `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`",
            "type": "string",
            "nullable": true
          },
          "who": {
            "title": "Who",
            "description": "`m`: only me, `mo`: me and others, `o`: only others",
            "type": "string",
            "enum": [
              "m",
              "mo",
              "o"
            ],
            "default": "o",
            "nullable": true
          },
          "send_reminders": {
            "title": "Send reminders",
            "description": "Automatically remind signers to sign a document, see: [automatic reminders](#section/Working-with-a-SignRequest/Automatic-reminders)",
            "type": "boolean"
          },
          "signers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Signer"
            }
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "document": {
            "title": "Document",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "integration": {
            "title": "Integration",
            "type": "string",
            "enum": [
              "mfiles",
              "salesforce",
              "formdesk",
              "zapier",
              "microsoft-flow"
            ],
            "nullable": true
          },
          "integration_data": {
            "title": "Integration data",
            "type": "object",
            "nullable": true
          },
          "name": {
            "title": "Name",
            "description": "Defaults to filename, including extension",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "external_id": {
            "title": "External id",
            "description": "ID used to reference document in external system",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "frontend_id": {
            "title": "Frontend id",
            "description": "Shared secret used in conjunction with <a href=\"#section/Frontend-API/SignRequest-js-client-(beta)\">SignRequest-js client</a> to grant user access to a document that's not a member of the document's team",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "file": {
            "title": "File",
            "description": "Temporary URL to original file, expires in five minutes",
            "type": "string",
            "readOnly": true,
            "format": "uri",
            "nullable": true
          },
          "file_from_url": {
            "title": "File from url",
            "description": "Publicly accessible URL of document to be downloaded by SignRequest",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "events_callback_url": {
            "title": "Events callback url",
            "description": "URL at which to receive [event callbacks](#section/Events/Events-callback) for this document",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "file_from_content": {
            "title": "File from content",
            "description": "Base64 encoded document content",
            "type": "string",
            "nullable": true
          },
          "file_from_content_name": {
            "title": "File from content name",
            "description": "Filename, including extension. Required when using `file_from_content`.",
            "type": "string",
            "nullable": true
          },
          "template": {
            "title": "Template",
            "type": "string",
            "format": "uri",
            "nullable": true
          },
          "prefill_tags": {
            "description": "Prefill signer input data, see [prefill tags](#section/Preparing-a-document/Prefill-tags-templates)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlinePrefillTags"
            }
          },
          "integrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlineIntegrationData"
            }
          },
          "file_from_sf": {
            "$ref": "#/components/schemas/FileFromSf"
          },
          "auto_delete_days": {
            "title": "Auto delete days",
            "description": "Number of days after which a finished document (signed/cancelled/declined) will be automatically deleted",
            "type": "integer",
            "maximum": 730,
            "minimum": 1,
            "nullable": true
          },
          "auto_expire_days": {
            "title": "Auto expire days",
            "description": "Number of days after which a non finished document will be automatically expired",
            "type": "integer",
            "maximum": 730,
            "minimum": 1,
            "nullable": true
          }
        }
      },
      "SignRequest": {
        "required": [
          "signers",
          "document"
        ],
        "type": "object",
        "properties": {
          "from_email": {
            "title": "From email",
            "description": "Email of user sending the SignRequest (must be a validated email)",
            "type": "string",
            "format": "email",
            "maxLength": 255,
            "minLength": 1
          },
          "from_email_name": {
            "title": "From email name",
            "description": "Name to be used in the `From` email header, e.g. `{from_email_name} <no-reply@signrequest.com>`",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "is_being_prepared": {
            "title": "Is being prepared",
            "description": "Have the sender of a SignRequest prepare the document before sending the request out, see: [prepare using the web interface](#section/Preparing-a-document/Prepare-using-the-web-interface)",
            "type": "boolean",
            "nullable": true
          },
          "prepare_url": {
            "title": "Prepare url",
            "type": "string",
            "format": "uri",
            "readOnly": true,
            "minLength": 1
          },
          "redirect_url": {
            "title": "Redirect url",
            "description": "URL at which SignRequest will redirect to when a document is signed",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "redirect_url_declined": {
            "title": "Redirect url declined",
            "description": "URL at which SignRequest will redirect to when a document is declined",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "required_attachments": {
            "description": "Attachments that signers are required to upload",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RequiredAttachment"
            }
          },
          "disable_attachments": {
            "title": "Disable attachments",
            "description": "Disable uploading/adding of attachments",
            "type": "boolean"
          },
          "disable_text_signatures": {
            "title": "Disable text signatures",
            "description": "Disable usage of signatures generated by typing (text)",
            "type": "boolean"
          },
          "disable_text": {
            "title": "Disable text",
            "description": "Disable adding of text",
            "type": "boolean"
          },
          "disable_date": {
            "title": "Disable date",
            "description": "Disable adding of dates",
            "type": "boolean"
          },
          "disable_emails": {
            "title": "Disable emails",
            "description": "Disable all SignRequest status emails as well as the email that contains the signed documents",
            "type": "boolean"
          },
          "disable_upload_signatures": {
            "title": "Disable upload signatures",
            "description": "Disable usage of uploaded signatures (images)",
            "type": "boolean"
          },
          "force_signature_color": {
            "title": "Force signature color",
            "description": "Force specific color for the signature",
            "type": "string",
            "maxLength": 100,
            "nullable": true
          },
          "disable_blockchain_proof": {
            "title": "Disable blockchain proof",
            "description": "Disables storing timestamp proof hashes in blockchain integrations.",
            "type": "boolean",
            "nullable": true
          },
          "text_message_verification_locked": {
            "title": "Text message verification locked",
            "description": "When true a text message verification is needed before the signer can see the document",
            "type": "boolean",
            "nullable": true
          },
          "subject": {
            "title": "Subject",
            "description": "Subject of SignRequest email",
            "type": "string",
            "maxLength": 512,
            "nullable": true
          },
          "message": {
            "title": "Message",
            "description": "Message to include in SignRequest email, may contain the following html tags: `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`",
            "type": "string",
            "nullable": true
          },
          "who": {
            "title": "Who",
            "description": "`m`: only me, `mo`: me and others, `o`: only others",
            "type": "string",
            "enum": [
              "m",
              "mo",
              "o"
            ],
            "default": "o",
            "nullable": true
          },
          "send_reminders": {
            "title": "Send reminders",
            "description": "Automatically remind signers to sign a document, see: [automatic reminders](#section/Working-with-a-SignRequest/Automatic-reminders)",
            "type": "boolean"
          },
          "signers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Signer"
            }
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "document": {
            "title": "Document",
            "type": "string",
            "format": "uri"
          },
          "integration": {
            "title": "Integration",
            "type": "string",
            "enum": [
              "mfiles",
              "salesforce",
              "formdesk",
              "zapier",
              "microsoft-flow"
            ],
            "nullable": true
          },
          "integration_data": {
            "title": "Integration data",
            "type": "object",
            "nullable": true
          }
        }
      },
      "ForwardSigner": {
        "required": [
          "signer_email_to_forward",
          "signer_email_to_forward_to"
        ],
        "type": "object",
        "properties": {
          "signer_email_to_forward": {
            "title": "Signer email to forward",
            "description": "Email of the signer that forwards the SignRequest.",
            "type": "string",
            "format": "email",
            "minLength": 1
          },
          "signer_email_to_forward_to": {
            "title": "Signer email to forward to",
            "description": "Email of the new signer to forward this SignRequest to.",
            "type": "string",
            "format": "email",
            "minLength": 1
          },
          "forwarded_reason": {
            "title": "Forwarded reason",
            "description": "A reason why this SignRequest is forwarded (optional), this will be visible to all parties involved",
            "type": "string",
            "maxLength": 1000,
            "minLength": 1
          }
        }
      },
      "TeamMember": {
        "type": "object",
        "properties": {
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "team": {
            "type": "object",
            "properties": {
              "name": {
                "title": "Name",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "subdomain": {
                "title": "Subdomain",
                "type": "string",
                "format": "slug",
                "pattern": "^[-a-zA-Z0-9_]+$",
                "readOnly": true,
                "minLength": 1
              },
              "url": {
                "title": "Url",
                "type": "string",
                "format": "uri",
                "readOnly": true
              }
            },
            "readOnly": true
          },
          "is_admin": {
            "title": "Is admin",
            "type": "boolean"
          },
          "is_active": {
            "title": "Active",
            "type": "boolean"
          },
          "is_owner": {
            "title": "Is owner",
            "type": "boolean"
          }
        }
      },
      "InlineTeamMember": {
        "type": "object",
        "properties": {
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "is_admin": {
            "title": "Is admin",
            "type": "boolean"
          },
          "is_active": {
            "title": "Active",
            "type": "boolean"
          },
          "is_owner": {
            "title": "Is owner",
            "type": "boolean"
          }
        }
      },
      "Team": {
        "required": [
          "name",
          "subdomain"
        ],
        "type": "object",
        "properties": {
          "name": {
            "title": "Name",
            "type": "string",
            "maxLength": 100,
            "minLength": 1
          },
          "subdomain": {
            "title": "Subdomain",
            "type": "string",
            "format": "slug",
            "maxLength": 100,
            "minLength": 1
          },
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "logo": {
            "title": "Logo",
            "type": "string",
            "readOnly": true,
            "format": "uri",
            "nullable": true
          },
          "phone": {
            "title": "Phone",
            "type": "string",
            "maxLength": 100
          },
          "primary_color": {
            "title": "Primary_color",
            "type": "string",
            "pattern": "^[#a-zA-Z0-9]+$",
            "maxLength": 100
          },
          "events_callback_url": {
            "title": "Events callback url",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "nullable": true
          },
          "documents_as_attachments": {
            "title": "Documents as attachments",
            "type": "boolean",
            "nullable": true
          },
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlineTeamMember"
            },
            "readOnly": true
          },
          "delete_after": {
            "title": "Delete after",
            "description": "When filled this team will be deleted after this date",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          },
          "sandbox": {
            "title": "Sandbox",
            "description": "Indicates whether team is in Sandbox mode",
            "type": "boolean",
            "readOnly": true
          }
        }
      },
      "InviteMember": {
        "required": [
          "email"
        ],
        "type": "object",
        "properties": {
          "email": {
            "title": "Email",
            "type": "string",
            "format": "email",
            "minLength": 1
          },
          "is_admin": {
            "title": "Is admin",
            "type": "boolean",
            "default": false
          },
          "is_owner": {
            "title": "Is owner",
            "type": "boolean",
            "default": false
          }
        }
      },
      "Placeholder": {
        "required": [
          "page_index",
          "prefill"
        ],
        "type": "object",
        "properties": {
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "s",
              "i",
              "n",
              "d",
              "t",
              "c"
            ]
          },
          "page_index": {
            "title": "Page index",
            "type": "integer"
          },
          "prefill": {
            "title": "Prefill",
            "type": "boolean"
          },
          "text": {
            "title": "Text",
            "type": "string",
            "nullable": true
          },
          "checkbox_value": {
            "title": "Checkbox value",
            "type": "boolean",
            "nullable": true
          },
          "date_value": {
            "title": "Date value",
            "type": "string",
            "format": "date",
            "nullable": true
          },
          "external_id": {
            "title": "External id",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          }
        }
      },
      "DocumentSignerTemplateConf": {
        "type": "object",
        "properties": {
          "signer_index": {
            "title": "Signer index",
            "type": "integer",
            "maximum": 2147483647,
            "minimum": -2147483648
          },
          "needs_to_sign": {
            "title": "Needs to sign",
            "description": "When `false` user does not need to sign, but will receive a copy of the signed document and signing log, see: [Copy only](#section/Additional-signing-methods/Copy-only)",
            "type": "boolean"
          },
          "approve_only": {
            "title": "Approve only",
            "description": "Require user to approve the document (without adding a signature), see: [Approve only](#section/Additional-signing-methods/Approve-only)",
            "type": "boolean"
          },
          "notify_only": {
            "title": "Notify only",
            "description": "Send notifications about the document and a copy of the signed document and signing log, but don't require them to take any action, see: [Notify only](#section/Additional-signing-methods/Notify-only)",
            "type": "boolean"
          },
          "in_person": {
            "title": "In person",
            "description": "When used in combination with an embed url on the sender, after sender has signed, they will be redirected to the next `in_person` signer, see: [In person signing](#section/Additional-signing-methods/In-person-signing)",
            "type": "boolean"
          },
          "order": {
            "title": "Order",
            "type": "integer",
            "maximum": 2147483647,
            "minimum": 0
          },
          "placeholders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Placeholder"
            },
            "readOnly": true
          }
        }
      },
      "Template": {
        "type": "object",
        "properties": {
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "name": {
            "title": "Name",
            "description": "Defaults to filename",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "user": {
            "$ref": "#/components/schemas/User"
          },
          "team": {
            "type": "object",
            "properties": {
              "name": {
                "title": "Name",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "subdomain": {
                "title": "Subdomain",
                "type": "string",
                "format": "slug",
                "pattern": "^[-a-zA-Z0-9_]+$",
                "readOnly": true,
                "minLength": 1
              },
              "url": {
                "title": "Url",
                "type": "string",
                "format": "uri",
                "readOnly": true
              }
            },
            "readOnly": true
          },
          "who": {
            "title": "Who",
            "description": "`m`: only me, `mo`: me and others, `o`: only others",
            "type": "string",
            "enum": [
              "m",
              "mo",
              "o"
            ]
          },
          "signers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSignerTemplateConf"
            },
            "readOnly": true
          }
        }
      },
      "WebhookSubscription": {
        "required": [
          "event_type",
          "callback_url"
        ],
        "type": "object",
        "properties": {
          "url": {
            "title": "Url",
            "type": "string",
            "format": "uri",
            "readOnly": true
          },
          "uuid": {
            "title": "Uuid",
            "type": "string",
            "readOnly": true,
            "minLength": 1
          },
          "name": {
            "title": "Name",
            "description": "Optional name to easily identify what webhook is used for",
            "type": "string",
            "maxLength": 255,
            "nullable": true
          },
          "event_type": {
            "title": "Event type",
            "type": "string",
            "enum": [
              "convert_error",
              "converted",
              "sending_error",
              "sent",
              "declined",
              "cancelled",
              "expired",
              "signed",
              "viewed",
              "downloaded",
              "signer_signed",
              "signer_email_bounced",
              "signer_viewed_email",
              "signer_viewed",
              "signer_forwarded",
              "signer_downloaded",
              "signrequest_received",
              "login_failed",
              "login_successful",
              "password_reset_request_sent",
              "password_reset_request_error"
            ]
          },
          "callback_url": {
            "title": "Callback url",
            "type": "string",
            "format": "uri",
            "maxLength": 2100,
            "minLength": 1
          },
          "integration": {
            "title": "Integration",
            "type": "string",
            "enum": [
              "mfiles",
              "salesforce",
              "formdesk",
              "zapier",
              "microsoft-flow"
            ],
            "nullable": true
          },
          "team": {
            "type": "object",
            "properties": {
              "name": {
                "title": "Name",
                "type": "string",
                "readOnly": true,
                "minLength": 1
              },
              "subdomain": {
                "title": "Subdomain",
                "type": "string",
                "format": "slug",
                "pattern": "^[-a-zA-Z0-9_]+$",
                "readOnly": true,
                "minLength": 1
              },
              "url": {
                "title": "Url",
                "type": "string",
                "format": "uri",
                "readOnly": true
              }
            },
            "readOnly": true
          },
          "created": {
            "title": "Créé",
            "type": "string",
            "format": "date-time",
            "readOnly": true
          }
        }
      }
    }
  }
}